---
Type:
aliases: 
tags: 
modifiedDate: 2025/06/12, 15:35:18
---

# C++锁

类似信号量, 互斥锁

## std::mutex

C++11 提供的最核心的锁是 **`std::mutex`** (Mutual Exclusion, 互斥锁)。
它是一个基础的互斥锁，提供了两个核心方法：
- `lock()`: 尝试获取锁。如果锁已被其他线程持有，则当前线程会**阻塞（block）**，直到获取到锁为止。
- `unlock()`: 释放锁，让其他等待的线程可以获取它。
**问题**：手动 `lock()` 和 `unlock()` 很危险。如果在临界区内发生异常或提前 `return`，`unlock()` 可能永远不会被调用，导致**死锁（Deadlock）**。

## std::lock_guard

[[C++11]] 引入, [[RAII]] 风格

**作用**：在其构造函数中自动获取锁 (`lock()`)，在其析构函数（离开作用域时）中自动释放锁 (`unlock()`)。
局部对象的析构函数在发生异常时也会发生, 所以会自动释放, 避免这种情况造成的死锁

## std::unique_lock

`std::unique_lock` 是一个功能更强大的锁包装器，它同样遵循RAII原则，但提供了 `std::lock_guard` 没有的灵活性：

- **可以延迟加锁**：可以在构造时不加锁，之后手动加锁。
- **可以提前解锁**：可以手动调用 `unlock()` 提前释放锁。
- **可以转移所有权**：可以将锁的所有权从一个 `unique_lock` 转移到另一个。
- **可以与条件变量配合使用**。
