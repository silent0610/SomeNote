---
Type: 
aliases: 
tags: 
modifiedDate: 2025/06/19, 09:23:05
---

# C++20新特性

## 自认为重要的

- [[C++Module]]
- [[C++Concepts]]
- [[C++Coroutines]]
- [[C++Ranges]]

## 重要性

### 👑 第一梯队：改变游戏规则的特性

#### 1. **模块 (Modules)**

- **说明**: 这是 C++20 最具革命性的特性。模块彻底改变了代码的组织方式，旨在最终取代传统的头文件 (`#include`)。它通过明确的接口导出和导入来组织代码，解决了头文件带来的诸多问题。
- **重要性**:
    - **编译速度极大提升**: 编译器只需编译一次模块接口，而不需要在每个包含它的源文件中重复解析头文件。
    - **更强的封装性**: 你可以精确控制哪些名称是外部可见的，隐藏内部实现细节，避免了宏的污染和命名冲突。
    - **告别头文件乱序问题**: 模块的导入顺序无关紧要，解决了长期以来因 `#include` 顺序不当导致的编译错误。

#### 2. **概念 (Concepts)**

- **说明**: 概念是 C++20 对模板元编程的巨大改进，它允许你对模板参数指定明确的约束。简而言之，它为模板参数定义了“类型”。
- **重要性**:
    - **极大地改善了编译错误信息**: 如果一个类型不满足模板的要求，编译器会直接告诉你“类型 X 不满足概念 Y”，而不是输出成百上千行难以理解的底层模板实例化错误。
    - **更清晰的接口**: 模板的接口变得自文档化，代码意图更加清晰，程序员一看就知道这个模板需要什么样的类型。
    - **函数重载更灵活**: 可以基于概念进行函数重载，编译器会选择最匹配的约束。

#### 3. **协程 (Coroutines)**

- **说明**: 协程是一种特殊的函数，它可以在执行中途暂停，并将控制权交还给调用者，之后又能从暂停点恢复执行。这为编写异步和协作式多任务代码提供了语言级的支持。
- **重要性**:
    - **简化异步编程**: 使用 `co_await`, `co_yield`, `co_return` 关键字，可以用看似同步的方式编写复杂的异步逻辑（如网络IO、事件处理），代码更易读、更易维护。
    - **高效的并发模型**: 协程是协作式的，挂起和恢复的开销远小于线程上下文切换，可以用来构建高性能的并发程序和生成器（generators）。
[[C++Coroutines]]

#### 4. **范围 (Ranges)**

[[C++Ranges]]
- **说明**: Ranges 库是对 STL 算法和迭代器模型的现代化升级。它允许你直接对一个容器（或其他可迭代对象）进行操作，而不是通过一对迭代器 `(begin, end)`。它还引入了视图（Views）和管道操作符 `|`。
- **重要性**:
    - **代码更简洁、可读性更高**: 可以将多个算法串联起来，形成声明式的处理流水线。例如 `view::filter | view::transform`。
    - **惰性求值**: 视图（Views）是惰性求值的，只有在需要时才计算结果，性能更高，且可以处理无限序列。
    - **更安全**: 消除了许多因迭代器失效或范围不匹配导致的常见错误。

---

### 🚀 第二梯队：重大改进与核心工具

这些特性极大地提升了开发效率和代码质量，是日常编程中的得力助手。

#### 5. **三路比较运算符 (Three-Way Comparison, a.k.a. Spaceship Operator `<=>`)**

对于 (a <=> b)，如果a > b ，则运算结果>0，如果a < b，则运算结果<0，如果 `a==b`，则运算结果等于0，注意下，运算符的结果类型会根据a和b的类型来决定，所以我们平时使用时候最好直接用auto，方便快捷。

```cpp
int main() {    
    double foo = 0.0;    
    double bar = 1.0;     
    auto res = foo <=> bar;     
    if (res < 0)        
        std::cout << "foo is less than bar";    
    else if (res == 0)        
        std::cout << "foo and bar are equal";    
    else if (res > 0)        
        std::cout << "foo is greater than bar";}
```

#### 6. **格式化库 (`std::format`)**

- **说明**: 一个现代、安全、可扩展的文本格式化库，功能上**类似于 Python** 的 `f-string` 或 C# 的 `String.Format`。它是 `iostream` 和 `printf` 的一个强大替代品。
- **重要性**:
    - **类型安全**: 在编译期检查格式字符串和参数类型是否匹配，杜绝了 `printf` 常见的类型不匹配漏洞。
    - **高性能**: 在很多场景下比 `iostream` 和 `snprintf` 更快。
    - **易用且强大**: 语法简洁直观，支持自定义类型的格式化。

```cpp
#include <iostream>
#include <string>
#include <format> // 引入 format 头文件

int main() {
    std::string name = "Alice";
    int age = 30;

    // 1. 基本使用
    std::string s1 = std::format("My name is {} and I am {} years old.", name, age);
    std::cout << s1 << std::endl; // 输出: My name is Alice and I am 30 years old.

    // 2. 可以通过索引指定参数顺序
    std::string s2 = std::format("I am {1} years old and my name is {0}.", name, age);
    std::cout << s2 << std::endl; // 输出: I am 30 years old and my name is Alice.

    // 3. 甚至可以重复使用参数
    std::string s3 = std::format("{0} is a good name. Hello, {0}!", name);
    std::cout << s3 << std::endl; // 输出: Alice is a good name. Hello, Alice!
}
```

#### 7. **`consteval` 和 `constinit`**

- **说明**:
    - `consteval`: 用于创建**立即函数 (Immediate Functions)**。这种函数必须在编译期产生一个常量结果，否则编译失败。
    - `constinit`: 用于变量声明，确保该变量在编译期（静态初始化阶段）完成初始化。
- **重要性**:
    - **增强的编译期编程**: `consteval` 保证了某些计算必须在编译期完成，提供了更强的元编程保证。
    - **解决静态初始化顺序问题**: `constinit` 确保了变量的初始化是静态的，避免了臭名昭著的“静态初始化顺序灾难”（static initialization order fiasco）。

#### 8. **`std::span`**

- **说明**: `std::span` 是一个非拥有（non-owning）的视图，它表示一个连续的内存序列（如数组、`std::vector`、`std::array` 的一部分）。
- **重要性**:
    - **统一接口**: 提供了一个统一的方式来传递连续数据，而无需关心其具体来源是 C 风格数组还是 `std::vector`。
    - **更安全**: 它包含了大小信息，可以进行边界检查，比传递原始指针和长度更安全。
    - **零开销抽象**: 它本身不拥有数据，只是一个轻量级的引用，没有性能开销。

---

### 👍 第三梯队：实用性强的日常改进

这些特性虽然不如前两者影响深远，但在日常编码中能显著提升代码的简洁度和表现力。

#### 9. **指定初始化 (Designated Initializers)**

- **说明**: 源自 C 语言的特性，允许你在初始化聚合类型（如 `struct`）时，通过成员名来指定初始值。
- **重要性**:
    - **可读性增强**: 明确了哪个值对应哪个成员，尤其是当构造函数参数很多或有多个相同类型的参数时。
    - **更稳定**: 即使结构体成员的顺序发生变化，初始化代码也无需修改。

#### 10. **Lambda 改进**

- **说明**: C++20 对 Lambda 表达式进行了多项增强。
- **重要性**:
    - **无状态 Lambda 可默认构造和赋值**: 方便在更多场景下使用 Lambda。
    - **允许在未捕获列表中使用 `[=]`**: 简化了模板代码中 Lambda 的编写。
    - **模板参数列表**: Lambda 也可以拥有自己的模板参数，使其更加通用和强大。

#### 11. **`using enum`**

- **说明**: 允许将一个枚举类型的所有成员直接引入当前作用域。
- **重要性**:
    - **简化代码**: 在 `switch` 语句或需要频繁使用枚举成员的场景下，可以省去重复的枚举类名作用域前缀（如 `Color::`）。

#### 12. **日历与时区库 (`<chrono>`)**

- **说明**: 对 `<chrono>` 库的巨大扩展，增加了处理日历日期、星期、月份以及不同时区的完整功能。
- **重要性**:
    - **标准化的日期时间处理**: 提供了一套强大且类型安全的工具来处理复杂的日期和时区计算，不再需要依赖第三方库。

---

### ✨ 第四梯队：特定领域的增强

这些特性在特定领域非常重要，但可能不是所有 C++ 程序员都会频繁使用。

- **原子操作的改进 (`std::atomic_ref`, `std::atomic::wait/notify`)**: `atomic_ref` 可以在非原子对象上执行原子操作，而 `wait/notify` 提供了比自旋等待更高效的线程同步方式。
- **`[[no_unique_address]]` 属性**: 允许编译器优化掉没有内容的成员变量所占用的空间，对于实现零开销抽象类型很有用。
- **位操作库 (`<bit>`)**: 提供了一组标准化的底层位操作函数，如计算二进制中1的个数 (`popcount`)、寻找最高位等，可移植性好且能利用硬件指令。
- **数学常量 (`<numbers>`)**: 在 `<numbers>` 头文件中定义了常用的数学常量，如 `std::numbers::pi` 和 `std::numbers::e`，精度更高且使用方便。
