---
Type: 
aliases:
  - 传输控制协议
  - Transmission Control Protocol
tags: 
modifiedDate: 2025/06/18, 22:51:32
---

# 传输控制协议

## 定义

TCP是一种**面向连接的、可靠的、基于字节流**的传输层通信协议。在发送数据之前，它必须在发送方和接收方之间建立一个可靠的连接，这个过程被称为“三次握手”。

## 特点

1. **可靠性高**：TCP保证数据能够完整、无误、按顺序地到达目的地。
    - **确认与重传**：接收方每收到一个数据包，都会向发送方发送一个确认（ACK）。如果发送方在一定时间内没收到确认，就会重新发送这个数据包。
    - **数据排序**：TCP会给每个数据包编号，接收方会根据编号重新组合，确保数据顺序正确。
    - **流量控制**：接收方会告诉发送方自己还能接收多少数据，防止发送方发送太快导致数据丢失。
    - **拥塞控制**：当网络繁忙时，TCP会主动减慢发送速度，防止网络崩溃。
2. **面向连接**：通信前必须先建立连接（三次握手），通信结束后需要释放连接（四次挥手）。整个过程如同打电话，需要先拨号接通，讲完话再挂断。
3. **开销较大**：为了保证可靠性，TCP需要维护连接状态、进行排序、确认和重传，这使得它的协议头部更复杂，开销和延迟也相对较大。

## 三次握手

![[assets/850de5c566ae60989f45cff4b1aad94c.png]]
- **SYN (Synchronize Sequence Numbers)**：同步序列号标志位。当SYN=1时，表明这是一个请求建立连接的报文。
- **ACK (Acknowledgment)**：确认标志位。当ACK=1时，表示确认号字段有效。
- **seq (Sequence Number)**：序列号。TCP是基于字节流的，这个字段表示当前报文中数据部分的第一个字节在整个字节流中的序号。在握手阶段，它是一个随机生成的初始序列号（ISN）。
- **ack (Acknowledgment Number)**：确认号。这个字段表示期望收到对方下一个报文的序列号。其值等于上次收到的对方报文的 `seq` 值加1。

流程
1. A 向 B 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。
2. B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
3. A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。
B 收到 A 的确认后，连接建立。

### 为什么需要进行三次握手

**为什么不能是两次？**
- 主要为了防止**已失效的连接请求报文突然又传送到了服务器，从而产生错误**。
- **场景**：假设客户端发送了一个连接请求A，但因为网络拥堵没能及时到达。客户端等不及了，就重新发送了另一个请求B，并成功建立了连接，传输数据，最后断开连接。此时，那个被网络“卡住”的旧请求A突然到达了服务器。如果是两次握手，服务器收到请求A后会立即认为连接已建立，并开始等待客户端发数据。但此时的客户端早已“人间蒸发”，服务器就会白白浪费资源等待一个不存在的连接。 
- 而三次握手解决了这个问题。服务器收到旧请求A后，会回复一个确认报文。但客户端根据自己的上下文，知道这是一个过期的请求，因此会忽略服务器的确认，不发送第三次握手的报文。服务器收不到第三次握手的确认，就知道连接建立失败，也就不会浪费资源了。

## 四次挥手

![[assets/0dc25c2e6ae3de02cc4039553165d8cf.png]]
- **FIN (Finish)**：结束标志位。当FIN=1时，表明发送方的数据已经全部发送完毕，请求断开连接。
- 第一次: 客户端将 FIN 置为 1, 表示我要结束连接, 没有数据要给服务器了. 同时附上当前消息的 seq
- 第二次: 服务器收到消息后, ACK =1,seq =v,[^1]ack=u+1,表示我知道你想要结束连接. **但这时候不能直接结束**
    - 服务器此时可能还有数据正在发送，或者正准备发送。服务器不能立即关闭自己的发送通道，所以它只能先回复一个 ACK（第二次挥手）来确认收到了客户端的关闭请求。
- 第三次: 服务器将所有数据发完后,;令FIN =1 向客服端发送消息, 表示我也要结束了, 你可以关闭接受消息通道了. 
- 第四次. 客户端收到消息后, 向服务器发送确认消息, 表示你可以关闭接收通道了, 随后关闭自己

==注意,第四次结束后, 客户端要等待 2MSL 才能彻底关闭, 原因见下==

### 为什么四次挥手?

**为什么挥手必须是四次？为什么第二次和第三次不能合并？** 这是四次挥手的核心。因为TCP是**全双工**通信，连接的关闭需要双向进行。
- 当客户端发送FIN（第一次挥手）时，仅表示**客户端**这一方向已经没有数据要发送了。但服务器此时可能还有数据正在发送，或者正准备发送。服务器不能立即关闭自己的发送通道，所以它只能先回复一个ACK（第二次挥手）来确认收到了客户端的关闭请求。
- 然后，服务器需要等到自己的数据全部发送完毕后，才能发送FIN报文（第三次挥手）来关闭自己的发送通道。 **简而言之，服务器的ACK和FIN是分开的，因为中间可能夹杂着尚未发送完毕的数据。**

### 为什么客户端最后要进入 `TIME_WAIT` 状态等待2MSL？

- **保证第四次挥手的ACK报文能成功到达服务器**。如果这个ACK丢失了，服务器会因为没收到确认而超时重传第三次挥手的FIN报文。客户端在`TIME_WAIT`状态下还能接收到这个重传的FIN，并重新发送ACK，从而帮助服务器正常关闭。如果没有这个等待状态，客户端直接关闭，就无法处理服务器的重传，导致服务器无法正常关闭。
- **防止“已失效的连接请求报文”出现在本连接中**。2MSL的时间足以让本次连接中双向传输的所有报文都从网络中消失，从而确保下一个使用相同端口号的新连接不会收到上一个旧连接残留的、迟到的数据包，避免数据混淆。

[^1]: 自己的消息序列号
