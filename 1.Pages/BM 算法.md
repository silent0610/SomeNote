---
Type: 
aliases:
  - Boyer Moore 算法
tags: 
modifiedDate: 星期三, 六月 4日 2025, 10:43:54 上午
---
[04. Boyer Moore 算法 | 算法通关手册（LeetCode）](https://algo.itcharge.cn/06.String/02.String-Single-Pattern-Matching/04.String-Boyer-Moore/)

## 关键

两种不同的**启发策略**来计算后移位数: [^1]
- **坏字符规则（The Bad Character Rule）**
- **好后缀规则（The Good Suffix Shift Rule）**

## 2\. Boyer Moore 算法启发策略

### 2.1 坏字符规则

> **坏字符规则（The Bad Character Rule）** ：当文本串 $T$ 中某个字符跟模式串 $p$ 的某个字符不匹配时，则称文本串 $T$ 中这个失配字符为 **「坏字符」** ，此时模式串 $p$ 可以快速向右移动。

「坏字符规则」的移动位数分为两种情况：

- **情况 1：坏字符出现在模式串 $p$ 中** 。
	- 这种情况下，可将模式串中最后一次出现的坏字符与文本串中的坏字符对齐，如下图所示。
	- **向右移动位数 = 坏字符在模式串中的失配位置 - 坏字符在模式串中最后一次出现的位置** 。
![情况 1：坏字符出现在模式串 p 中](https://qcdn.itcharge.cn/images/20240511164026.png)

情况 1：坏字符出现在模式串 p 中

- **情况 2：坏字符没有出现在模式串 $p$ 中** 。
	- 这种情况下，可将模式串向右移动一位，如下图所示。
	- **向右移动位数 = 坏字符在模式串中的失配位置 + 1** 。
![情况 2：坏字符没有出现在模式串 p 中](https://qcdn.itcharge.cn/images/20240511164048.png)

情况 2：坏字符没有出现在模式串 p 中

### 2.2 好后缀规则

> **好后缀规则（The Good Suffix Shift Rule）** ：当文本串 $T$ 中某个字符跟模式串 $p$ 的某个字符不匹配时，则称文本串 $T$ 中已经匹配好的字符串为 **「好后缀」** ，此时模式串 $p$ 可以快速向右移动。

「好后缀规则」的移动方式分为三种情况：

- **情况 1：模式串中有子串匹配上好后缀** 。
	- 这种情况下，移动模式串，让该子串和好后缀对齐即可。如果超过一个子串匹配上好后缀，则选择最右侧的子串对齐，如下图所示。
	- **向右移动位数 = 好后缀的最后一个字符在模式串中的位置 - 匹配的子串最后一个字符出现的位置** 。
![情况 1：模式串中有子串匹配上好后缀](https://qcdn.itcharge.cn/images/20240511164101.png)

情况 1：模式串中有子串匹配上好后缀

- **情况 2：模式串中无子串匹配上好后缀，但有最长前缀匹配好后缀的后缀** 。
	- 这种情况下，我们需要在模式串的前缀中寻找一个最长前缀，该前缀等于好后缀的后缀。找到该前缀后，让该前缀和好后缀的后缀对齐。
	- **向右移动位数 = 好后缀的后缀的最后一个字符在模式串中的位置 - 最长前缀的最后一个字符出现的位置** 。
![情况 2：模式串中无子串匹配上好后缀， 但有最长前缀匹配好后缀的后缀](https://qcdn.itcharge.cn/images/20240511164112.png)

情况 2：模式串中无子串匹配上好后缀， 但有最长前缀匹配好后缀的后缀

- **情况 3：模式串中无子串匹配上好后缀，也找不到前缀匹配** 。
	- 可将模式串整个右移。
	- **向右移动位数 = 模式串的长度** 。
![情况 3：模式串中无子串匹配上好后缀，也找不到前缀匹配](https://qcdn.itcharge.cn/images/20240511164124.png)

情况 3：模式串中无子串匹配上好后缀，也找不到前缀匹配

## 3\. Boyer Moore 算法匹配过程示例

下面我们根据 J Strother Moore 教授给出的例子，先来介绍一下 BF 算法的匹配过程，顺便加深对 **「坏字符规则」** 和 **「好后缀规则」** 的理解。

假设文本串为 `"HERE IS A SIMPLE EXAMPLE"` ，模式串为 `"EXAMPLE"` ，如下图所示。

![Boyer Moore 算法步骤 1](https://qcdn.itcharge.cn/images/20220127164130.png)

Boyer Moore 算法步骤 1

首先，令模式串与文本串的头部对齐，然后从模式串的尾部开始逐位比较，如下图所示。

![Boyer Moore 算法步骤 2](https://qcdn.itcharge.cn/images/20220127164140.png)

Boyer Moore 算法步骤 2

可以看出来， `'S'` 与 `'E'` 不匹配。这时候，不匹配的字符 `'S'` 就被称为「坏字符（Bad Character）」，对应着模式串的第 $6$ 位。并且 `'S'` 并不包含在模式串 `"EXAMPLE"` 中（相当于 `'S'` 在模式串中最后一次出现的位置是 $-1$ ）。根据「坏字符规则」，可以把模式串直接向右移动 $6 - (-1) = 7$ 位，即将文本串中 `'S'` 的后一位上。

将模式串向右移动 $7$ 位。然后依然从模式串尾部开始比较，发现 `'P'` 和 `'E'` 不匹配，则 `'P'` 是坏字符，如下图所示。

![Boyer Moore 算法步骤 3](https://qcdn.itcharge.cn/images/20220127164151.png)

Boyer Moore 算法步骤 3

但是 `'P'` 包含在模式串 `"EXAMPLE"` 中， `'P'` 这个坏字符在模式串中的失配位置是第 $6$ 位，并且在模式串中最后一次出现的位置是 $4$ （编号从 $0$ 开始）。

根据「坏字符规则」，可以将模式串直接向右移动 $6 - 4 = 2$ 位，将文本串的 `'P'` 和模式串中的 `'P'` 对齐，如下图所示。

![Boyer Moore 算法步骤 4](https://qcdn.itcharge.cn/images/20220127164202.png)

Boyer Moore 算法步骤 4

我们继续从尾部开始逐位比较。先比较文本串的 `'E'` 和模式串的 `'E'` ，如下图所示。可以看出文本串的 `'E'` 和模式串的 `'E'` 匹配，则 `"E"` 为好后缀， `"E"` 在模式串中的位置为 $6$ （编号从 $0$ 开始）。

![Boyer Moore 算法步骤 5](https://qcdn.itcharge.cn/images/20220127164212.png)

Boyer Moore 算法步骤 5

继续比较前面一位，即文本串的 `'L'` 和模式串的 `'L'` ，如下图所示。可以看出文本串的 `'L'` 和模式串的 `'L'` 匹配。则 `"LE"` 为好后缀， `"LE"` 在模式串中的位置为 $6$ （编号从 $0$ 开始）。

![Boyer Moore 算法步骤 6](https://qcdn.itcharge.cn/images/20220127164222.png)

Boyer Moore 算法步骤 6

继续比较前面一位，即文本串中的 `'P'` 和模式串中的 `'P'` ，如下图所示。可以看出文本串中的 `'P'` 和模式串中的 `'P'` 匹配，则 `"PLE"` 为好后缀， `"PLE"` 在模式串中的位置为 $6$ （编号从 $0$ 开始）。

![Boyer Moore 算法步骤 7](https://qcdn.itcharge.cn/images/20220127164232.png)

Boyer Moore 算法步骤 7

继续比较前面一位，即文本串中的 `'M'` 和模式串中的 `'M'` ，如下图所示。可以看出文本串中的 `'M'` 和模式串中的 `'M'` 匹配，则 `"MPLE"` 为好后缀。 `"MPLE"` 在模式串中的位置为 $6$ （编号从 $0$ 开始）。

![Boyer Moore 算法步骤 8](https://qcdn.itcharge.cn/images/20220127164241.png)

Boyer Moore 算法步骤 8

继续比较前面一位，即文本串中的 `'I'` 和模式串中的 `'A'` ，如下图所示。可以看出文本串中的 `'I'` 和模式串中的 `'A'` 不匹配。

![Boyer Moore 算法步骤 9-1](https://qcdn.itcharge.cn/images/20220127164251.png)

Boyer Moore 算法步骤 9-1

此时，如果按照「坏字符规则」，模式串应该向右移动 $2 - (-1) = 3$ 位。但是根据「好后缀规则」，我们还有更好的移动方法。

在好后缀 `"MPLE"` 和好后缀的后缀 `"PLE"` 、 `"LE"` 、 `"E"` 中，只有好后缀的后缀 `"E"` 和模式串中的前缀 `"E"` 相匹配，符合好规则的第二种情况。好后缀的后缀 `"E"` 的最后一个字符在模式串中的位置为 $6$ ，最长前缀 `"E"` 的最后一个字符出现的位置为 $0$ ，则根据「好后缀规则」，可以将模式串直接向右移动 $6 - 0 = 6$ 位。如下图所示。

![Boyer Moore 算法步骤 9-2](https://qcdn.itcharge.cn/images/20220127164301.png)

Boyer Moore 算法步骤 9-2

继续从模式串的尾部开始逐位比较，如下图所示。

可以看出， `'P'` 与 `'E'` 不匹配， `'P'` 是坏字符。根据「坏字符规则」，可以将模式串直接向右移动 $6 - 4 = 2$ 位，如下图所示。

![Boyer Moore 算法步骤 10](https://qcdn.itcharge.cn/images/20220127164312.png)

Boyer Moore 算法步骤 10

继续从模式串的尾部开始逐位比较，发现模式串全部匹配，于是搜索结束，返回模式串在文本串中的位置。

## 4\. Boyer Moore 算法步骤

整个 BM 算法步骤描述如下：

1. 计算出文本串 $T$ 的长度为 $n$ ，模式串 $p$ 的长度为 $m$ 。
2. 先对模式串 $p$ 进行预处理，生成坏字符位置表 $bc\underline{\hspace{0.5em}}table$ 和好后缀规则后移位数表 $gs\underline{\hspace{0.5em}}talbe$ 。
3. 将模式串 $p$ 的头部与文本串 $T$ 对齐，将 $i$ 指向文本串开始位置，即 $i = 0$ 。 $j$ 指向模式串末尾位置，即 $j = m - 1$ ，然后从模式串末尾位置开始进行逐位比较。
	1. 如果文本串对应位置 $T[i + j]$ 上的字符与 $p[j]$ 相同，则继续比较前一位字符。
		1. 如果模式串全部匹配完毕，则返回模式串 $p$ 在文本串中的开始位置 $i$ 。
	2. 如果文本串对应位置 $T[i + j]$ 上的字符与 $p[j]$ 不相同，则：
		1. 根据坏字符位置表计算出在「坏字符规则」下的移动距离 $bad\underline{\hspace{0.5em}}move$ 。
		2. 根据好后缀规则后移位数表计算出在「好后缀规则」下的移动距离 $good\underline{\hspace{0.5em}}mode$ 。
		3. 取两种移动距离的最大值，然后对模式串进行移动，即 $i += max(bad\underline{\hspace{0.5em}}move, good\underline{\hspace{0.5em}}move)$ 。
4. 如果移动到末尾也没有找到匹配情况，则返回 $-1$ 。

[^1]: 启发策略的计算过程只与模式串 p 相关，而与文本串 T 无关。**取最大**
