---
Type:
  - Page
aliases: 
tags: 
modifiedDate: 2025/06/12, 22:16:58
---

# 虚表的实现

[C++虚表](C++虚表.md)

## 单继承下的虚表实现

- **每个拥有虚函数的类都会有一个唯一的虚表 (vtable)**。这个虚表是一个函数指针数组。
- **每个虚函数在虚表中都有一个固定的槽位 (slot)**。这个槽位由虚函数在其类继承体系中的声明顺序决定。
- **每个对象会有一个虚表指针 (vptr)**。这个 `vptr` 通常是对象实例内存布局的第一个成员（或者在某些编译器下是固定偏移），它指向该对象实际类型对应的虚表。

当调用 `basePtr->f()` 时：
1. 通过 `basePtr` 找到对象实例的 `vptr`。
2. 通过 `vptr` 找到正确的虚表（例如 `vtable_Derived`）。
3. 在虚表槽位 0 处找到函数指针。
4. 调用 `Derived::f()`。

## 多继承下的虚表实现

通常使用**多虚表**方法
- **多个** 虚表指针(N或 N+1, 假如自己也引入了新的虚函数). 每个 `vptr` 对应一个特定的基类子对象或整个派生类对象。
- 偏移调整

### 为什么?

#### 基类指针/引用的多态性需求 根本

这是最根本的原因。当通过**基类指针或引用**调用虚函数时，C++ 必须保证正确的行为。

- 考虑 `Base1* ptr1 = new Derived();` 和 `Base2* ptr2 = new Derived();`。
- 当调用 `ptr1->someVirtualFunc()` 时，编译器会查找 `ptr1` 所指向的**`Base1` 子对象**的虚表指针。这个 `vptr` 必须指向一个能正确解析 `Base1` 虚函数的虚表。
- 当调用 `ptr2->someVirtualFunc()` 时，编译器会查找 `ptr2` 所指向的**`Base2` 子对象**的虚表指针。这个 `vptr` 必须指向一个能正确解析 `Base2` 虚函数的虚表。

如果只有一个虚表，编译器将无法区分是通过 `Base1` 接口调用还是通过 `Base2` 接口调用，因为它们可能会有不同的虚函数布局和不同的 `this` 指针调整需求。

#### 虚函数槽位（Slot）的冲突与一致性

- **单继承的简单性**：在单继承中，派生类继承了基类的虚函数表结构。`Base::f()` 在虚表中是槽位 0，`Base::g()` 是槽位 1。`Derived` 可以在相同的槽位上重写这些虚函数。
- **多继承的复杂性**：假设类 `Derived` 继承自 `Base1` 和 `Base2`，并且 `Base1` 和 `Base2` 都各自有虚函数 `f()`。

如果只有一个虚表，那么 `Base1::f()` 和 `Base2::f()` 都需要一个槽位。但它们是不同的函数，拥有不同的意义和调用上下文。如果它们都使用同一个槽位，就会产生冲突。 更重要的是，即使虚函数名不同，它们在各自基类虚表中的相对位置也可能是独立的。把它们强行塞进一个虚表，会破坏这种独立的槽位布局。
