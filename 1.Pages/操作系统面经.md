---
Type:
aliases: 
tags: 
modifiedDate: 2025/06/18, 21:52:51
---

# 操作系统面经

- 什么是进程
    - [[进程]]
- 什么是线程
    - [[线程]]
- 进程和线程的区别
    - [[线程和进程的区别]]
- 线程最大的缺点是什么？
    - [[线程#缺点]]
- 你能讲一下有哪几种锁吗？
    - **互斥锁（Mutex）**：互斥锁是最常见的一种锁，用于保护共享资源的互斥访问。一次只有一个线程可以获得互斥锁。如果其他线程试图获得已经被锁定的互斥锁，它们将被阻塞，直到锁被释放。
    - **递归锁（Recursive Lock）**：递归锁是一种特殊的互斥锁，允许同一个线程多次获得同一个锁，而不会导致死锁。递归锁维护了一个锁计数器和一个拥有锁的线程标识。
    - **读写锁（Read-Write Lock）**：读写锁允许多个线程同时读取共享资源，但在写入时需要互斥访问。这可以提高在读操作远多于写操作的场景下的性能。
    - **自旋锁（Spinlock）**：自旋锁是一种特殊的锁，当锁已经被其他线程获得时，尝试获得锁的线程将忙等待（在一个循环中不断尝试获得锁），而不是被阻塞。自旋锁适用于锁持有时间非常短的场景。
- 互斥锁线程的阻塞和唤醒的原理？
    - 互斥锁的线程挂起和通知通常是由操作系统和编程语言的线程实现的。当一个线程试图获取已经被另一个线程持有的互斥锁时，它会被挂起，**直到锁被释放**。以下是挂起和通知的一般过程：
        1. 当一个线程尝试获取互斥锁时，线程库会检查该锁是否已经被其他线程持有。
        2. 如果锁没有被持有，线程库会将锁分配给请求线程，然后线程可以继续执行。
        3. 如果锁已经被其他线程持有，线程库会将请求线程挂起。挂起的线程会被移出CPU的调度队列，进入等待队列，直到锁被释放。这样可以确保挂起的线程不会消耗CPU资源。
        4. 当持有锁的线程完成对共享资源的操作并释放锁时，线程库会从等待队列中选择一个或多个挂起的线程，并将它们重新加入调度队列。
        5. 被唤醒的线程会再次尝试获取锁。如果成功，线程将继续执行；否则，线程将再次被挂起，等待下一次通知。
- 缺页中断什么时候发生？
    1. 当程序试图访问的页面（Page）不在物理内存（RAM）中时，操作系统无法立即满足这个请求，这将触发一个缺页中断。这种情况通常发生在**虚拟内存系统**中，其中只有部分页面被加载到物理内存中。
    2. 当程序试图执行的操作违反了内存保护规则时，也会触发缺页中断。例如，程序试图写入一个只读页面，或者试图访问一个没有权限访问的页面。
- 常见的页面置换的算法？
    1. 最近最少使用（Least Recently Used，LRU）：此算法选择最近最少使用的页面进行替换。它的优点是能够较好地处理局部性原理，即最近使用过的页面在未来很可能还会被使用。缺点是实现起来相对复杂，需要维护一个所有页面的使用记录列表。
    2. 最不经常使用（Least Frequently Used，LFU）：此算法选择使用频率最低的页面进行替换。它的优点是对于长期稳定的访问模式，能够得到较好的性能。缺点是如果访问模式发生变化，可能会导致性能下降，因为使用频率高的页面可能在未来不再被访问。
    3. 先进先出（First In First Out，FIFO）：此算法选择最早进入内存的页面进行替换。它的优点是实现简单，不需要记录页面的使用情况。缺点是可能会导致性能下降，因为最早进入内存的页面并不一定是最少使用的。
    4. **时钟和改进时钟**：此算法使用一个循环队列和一个“最近使用”位来模拟LRU算法。它的优点是实现相对简单，同时能够得到接近LRU的性能。缺点是如果访问模式发生变化，可能会导致性能下降。
    5. 最优（Optimal）：此算法选择未来最长时间不会被访问的页面进行替换。它的优点是理论上能够得到最好的性能，因为总是选择最不可能被使用的页面进行替换。缺点是在实践中无法实现，因为无法预知未来的访问模式。
- 原码和补码？
    - **原码就是符号位加上真值的绝对值**, 即用第一位表示符号，其余位表示值。适合人类理解, 但最大的问题就是有歧义, 即 0 存在两种表示,有正 0 和负 0. cpu 不好处理
    - [[补码]]
- 进程调度算法？
    1. FCFS：先来先服务
        1. 非抢占式。按照请求的时间顺序进行调度
        2. 有利于长作业，不利于短作业
    2. SJF：短作业优先
        1. 非抢占式：按照运行时间最短的顺序进行调度
        2. 长作业可能会一直等待，得不到调度
    3. SRTN：最短剩余时间优先
        1. SJF的抢占式版本
        2. 当一个新的作业到达时，将其运行时间与当前作业的剩余时间进行比较
    4. 时间片轮转
        1. 将左右作业按照FCFS排成队列，每次调度时，将CPU时间分配给队首，执行完一个时间片之后，放入队尾。
        2. 如果时间片太短，会导致进程切换频繁，开销大。如果时间片太长，实时性就得不到保证。
    5. 优先级调度
        1. 为每个进程分配一个优先级，按照优先级进行调度
        2. 为了防止低优先级的进程永远得不到调度，可以随着时间推移，增加等待进程的优先级。
    6. 多级反馈队列, window
        1. 将时间片轮转和优先级调度结合
        2. 不同的队列优先级不同，执行的时间片也不同
    - Linux 和安卓
        - 在保证CPU时间分配公平性的基础上，额外关注任务的延迟敏感性。
