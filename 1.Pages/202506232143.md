---
Type: 
aliases:
  - 预计算传输（PRT）解释
tags: 
modifiedDate: 2025/06/23, 21:44:19
---

# 202506232143

## 核心思想：预计算“传输”

首先，这个系统的总称是**预计算光照传输（PRT）**。它的核心思想正如您所说：**假设场景的几何结构不变，只有光照可以动态变化**。

- **预计算（Precomputation）**：在游戏打包或加载关卡之前，离线进行大量耗时的计算。
- **传输（Transfer）**：真正被预计算的东西不是光照本身，而是**光线的传播路径和相互作用的方式**。比如，A点反弹的光有多少比例能到达B点，B点能看到多少比例的天空，等等。

这个系统通过一个**三级数据结构（面元 Surfel -> 砖块 Brick -> 探针 Probe）**来组织和存储这些“传输”信息。

---

## 第一阶段：离线预计算（烘焙）

这个阶段在开发时完成，为运行时做好一切准备。

### 1. 探针布局 (Probe Placement)

> “分块顶部获取高度图，每隔4m生成一个probe；避免空腔”

- **解释**：系统首先要在场景中放置大量的“眼睛”，也就是探针（Probe），用来感知光照。为了高效地做到这一点，系统会：
    1. 从上向下扫描场景，生成一张类似地形图的**高度图**。
    2. 在这张高度图上，以4米的固定间隔，像棋盘一样放置探针。
    3. 通过射线检测等方式**避免将探针放置在无效区域**，比如墙体内部、地底下等“空腔”中。一个有效的探针必须位于玩家可以到达的开放空间。

### 2. 生成面元 (Surfel Generation)

> “在probe位置上生成cubemap，记录normal，worldpos，albedo” “从probe发射光线，生成surfel，将一定范围内的surfel划分为一个brick；将相同位置上的surfel平均合并，拆分surfel，记录天空可见性”

- **解释**：这是预计算的核心。
    1. **光线发射**：从每一个探针的位置，向四面八方发射大量光线（就像生成一个立方体贴图 Cubemap）。
    2. **创建面元**：当一条光线射到场景的某个表面时，就在这个击中点上创建一个**面元（Surfel）**。
    3. **存储信息**：这个面元是一个基础数据单元，它记录了该点的**物理表面信息**：世界坐标位置（Position）、表面法线（Normal）和基础颜色（Albedo）。
    4. **记录天空可见性**：对于每个新创建的面元，系统会再次从它自己的位置向天空方向发射探测光线，计算它有多大比例能直接看到天空。这个**天空可见度（Sky Visibility）**值被存储起来，用于运行时计算天空光。
    5. **优化**：为了让面元分布更均匀、数据更规整，系统会进行一些优化，比如合并过于靠近的面元，或者在数据稀疏的地方适当拆分增加面元。

### 3. 构建数据层级 (Building the Hierarchy)

> “Surfel是实时PRTGI最基础的单位...Brick为Surfel的上一级...Probe为Brick的上一级...”

- **解释**：在生成了数百万个离散的面元后，为了能快速查找和管理它们，系统会建立一个金字塔式的数据结构：
    1. **面元 (Surfel)**：最底层的原子单位。代表了场景表面上的一个真实物理点。精度为1米，意味着大概每平方米的表面上会有一个面元。
    2. **砖块 (Brick)**：面元的上一级容器。系统将空间划分为4x4x4米的网格，每个网格就是一个“砖块”。砖块本身不存储面元的详细数据，而是存储一个**索引列表**，指向它空间范围内的所有面元。这是一种高效的数据压缩和组织方式。
    3. **探针 (Probe)**：最高级的“光照信息采集点”。对于每个探针，系统会计算它周围哪些砖块会对它产生光照贡献，并记录下这些**砖块的索引**以及它们各自的**权重**（比如距离越近，权重越高）。

至此，离线预计算完成。我们得到了一套完整的、描述了光线如何在场景中传递的数据结构。

---

## 第二阶段：实时运行（游戏中）

当玩家在游戏中游玩时，系统利用预计算好的数据来实时渲染动态的全局光照。

### 1. 在面元上计算光照

> “运行时，在surfel上计算光照效果，持续使用shadow信息，直到下一个可用的”

- **解释**：每一帧，对于场景中所有的动态光源（比如太阳、手电筒、爆炸等）：
    1. 系统会计算这个光源对**每一个面元**的直接光照贡献。
    2. 这个计算需要判断光源是否能照到面元，即进行**阴影检测**。这里会利用实时阴影图（Shadow Map）来高效完成。
    3. 所有面元被直接光照“点亮”后，它们就成为了新的间接光源。

### 2. 传递光照信息到探针

> “混合生成probe的颜色”

- **解释**：面元的光照信息需要被传递给探针，供最终渲染使用。
    1. 每个探针根据自己预计算好的**“砖块贡献列表”**，去查找对应砖块。
    2. 然后收集这些砖块内所有面元的**光照颜色**。
    3. 将这些颜色根据预计算好的**权重**进行加权平均混合，就得到了这个探针所代表区域的整体间接光照颜色。
    4. 同时，利用之前预计算的**天空可见度**，将天空光也混合进来。

### 3. 探针的存储与最终着色

> “probe的存储方式有很多，ambient cube，2阶球谐” “分块加载probe”

- **解释**：
    1. 探针计算出的最终光照信息是带有方向性的（比如左边是红墙反弹的红光，头顶是天空的蓝光）。为了高效存储这种方向性光照，系统会使用**球谐函数（Spherical Harmonics, SH）**或**环境立方体（Ambient Cube）**等技术进行编码。二阶球谐函数（2nd order SH）只需要9个浮点数，就能很好地表示柔和的漫反射环境光，非常高效。
    2. 当渲染屏幕上的一个像素时，GPU会找到离它最近的几个探针，读取它们的球谐光照数据，进行插值混合，最终得到该像素所接收到的间接光照，并添加到最终颜色上。
    3. 由于整个场景的探针数据量可能非常庞大，系统会根据玩家位置**分块动态加载**，只把玩家附近的探针数据读入内存，以节省资源。

## 总结

您描述的是一个设计精良的多层级缓存GI系统。它通过：

1. **离线预计算**，将复杂的几何体相互关系（光线传递路径）固化下来，存储在**Surfel -> Brick -> Probe**这个层级结构中。
2. **实时运行时**，只计算动态光源对最底层**Surfel**的直接影响。
3. 然后利用预计算好的层级关系，高效地将光照信息从**Surfel**向上传递和汇集到**Probe**。
4. 最终，渲染器使用这些包含了完整间接光照信息的**Probe**，为场景提供高质量的全局光照。

这是一个典型的用“空间换时间”的思想，以庞大的预计算数据为代价，换取了极高运行效率的解决方案。
