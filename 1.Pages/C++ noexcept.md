---
Type:
aliases: 
tags: 
modifiedDate: 2025/06/12, 15:08:01
---

# C++ Noexcept

C++11 引入的**关键字**

## 作用

当 `noexcept` 作为函数修饰符时，它向编译器做出一个**郑重的承诺**：**“我这个函数绝对不会抛出任何异常。”**

> 可以违背承诺, 但是会导致退出
 `noexcept` 是一个具有法律效力的合同。如果你向编译器承诺一个函数是 `noexcept` 的，但它实际上却抛出了异常，那么程序不会去捕获这个异常。

### 启用并优化移动语义

像 `std::vector` 这样的容器，在进行某些操作（比如 `push_back` 导致容量扩充）时，会尽力提供**强异常安全保证**。这意味着，如果操作中途失败（例如，因为抛出了异常），容器会回滚到操作开始前的状态，就像什么都没发生过一样。

> [!note]- 移动操作的风险
> 当 `std::vector` 需要扩容时，它会：
>   1. 申请一块更大的新内存。
>  2. 将旧内存中的元素**移动或复制**到新内存中。
> 3. 释放旧内存。
> - 如果使用**拷贝**：即使在拷贝第N个元素时，其拷贝构造函数抛出异常，也没关系。因为所有旧元素都还在，`vector` 只需释放新内存，即可安全地回到原始状态。  
> - 如果使用**移动**：这就有风险了。假设我们把第1、2、3个元素从旧内存**移动**到新内存，在移动第4个元素时，它的**移动构造函数抛出了异常**。此时，第1、2、3个元素的旧位置已经被“掏空”（资源被窃取），我们无法将它们安全地恢复原状了！强异常安全保证被打破。

为了保证**强异常安全**，`std::vector` 在扩容时会进行检查：
- 如果要移动的对象的**移动构造函数被标记为 `noexcept`**，`vector` 就知道这个移动操作是100%安全的，不会抛异常。于是它会放心地使用**快速的移动操作**。
- 如果移动构造函数**没有被标记为 `noexcept`**，`vector` 就认为这个移动操作有抛异常的风险。为了保证强异常安全，它会**放弃使用移动，转而使用更慢但更安全的拷贝操作**。

### 编译器优化

当编译器知道一个函数不会抛出异常时，它可以生成更精简、更高效的代码。
- **无需生成栈展开（Stack Unwinding）代码**：异常发生时，需要沿着调用栈逐层销毁对象，这个过程叫栈展开。如果函数是 `noexcept` 的，编译器就不需要为这个函数生成相关的清理代码。
- **更多的优化机会**：编译器可以更大胆地进行指令重排等优化，因为它不必担心这些优化会影响异常处理的逻辑。

## 实践

- **总是**将移动构造函数、移动赋值运算符和析构函数标记为 `noexcept`。
- 对于那些你确定不会抛出异常的简单函数（如简单的getter/setter），也应标记为 `noexcept`。
- 在编写泛型代码时，使用有条件的 `noexcept` 来传递和维持异常保证。
- **不要**在你无法保证的函数上使用 `noexcept`（例如，可能分配内存、进行I/O操作或调用其他可能抛异常的函数的函数）。
