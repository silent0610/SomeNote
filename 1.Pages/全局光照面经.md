---
Type:
aliases: 
tags: 
modifiedDate: 2025/06/24, 12:47:00
---

# 全局光照面经

## 全局光照大合集

### 通用全局光照方法

1. 辐射度算法：有限元方法，假设每个表面都由一定数量的面片组成，对每个面片计算一个平均辐射度，并计算面片之间的形状因子。然后对这个线性方程组进行迭代计算。
2. 光线追踪方法：蒙特卡洛方法，光线追踪的基本思想可以用于求解完整的渲染方程。利用光路可逆原理，对光线在场景中的传播路径进行积分，从而计算最终进入相机的radiance。重要性采样。

### 环境光遮蔽 AO

**考虑着色点半球范围内的可见性**
1. 理论：投射光线，根据是否遮挡（0-1）来计算可见性系数；使用距离映射函数（连续函数）来计算可见性函数，设置最大相交距离；考虑相互反射。
2. 预计算：蒙特卡洛方法，离线计算场景中的环境光遮蔽。
3. 物体空间动态计算：使用圆盘替代，解析计算；SDF；锥形追踪；近似球体。
4. 屏幕空间动态计算
    1. SSAO：球形采样，对比深度缓冲
    2. HBAO：在若干（4）方向上，寻找半球视界角，对可见性进行近似
    3. GTAO：对比 HBAO,使用余弦加权；拟合曲线，模拟多次弹射。

### 定向遮蔽

在计算遮挡关系的同时还会考虑光照信息；
- SSAO认为间接光来源于远处的未被遮挡的光线，
- 而SSDO则认为它们来自于**周围较近的遮挡物体的反射**。
上半球随机采样，计算采样点的颜色，并对当前着色点产生影响。

### Diffuse GI

#### 预计算irradiance信息 （烘焙），存储在某种基底上

#### 预计算传输 （PRT）

 假设场景不变，只有光照变化。对光线与场景的相互作用进行预计算。将场景周围的光照信息存储在probe中，运行时插值。
1. 在probe位置上生成cubemap，记录normal，worldpos，albedo
2. 从probe发射光线，生成surfel，将一定范围内的surfel划分为一个brick；将相同位置上的surfel平均合并，拆分surfel，记录天空可见性
3. 运行时，在surfel上计算光照效果，持续使用shadow信息，直到下一个可用的；混合生成probe的颜色；分块加载probe
4. probe的存储方式有很多，ambient cube，2阶球谐
5. probe摆放：分块顶部获取高度图，每隔4m生成一个probe；避免空腔
Surfel是实时PRTGI最基础的单位，该单位存储了自己的Position，以及场景在该位置的Normal和Albedo信息，精度为1米1个。
Brick为Surfel的上一级，精度为4米1个，保存了在它精度范围内的Surfel的索引（不需要存储位置）。
Probe为Brick的上一级，精度随具体布置而定，保存了自己的位置、附近对自己产生颜色贡献的Brick的索引和对自己的权重以及天空的可见度信息（Sky Visibility）。）
[[202506232143|预计算传输（PRT）解释]]

#### RSM

[[RSM]] 光源map，将纹素视为虚拟点光源，提供单次弹射的效果。重要性驱动, ConeTracing

#### LPV

[[LPV]]
LPV：场景离散为三维网格，单元格内维护radiance场。首先找到包含直接光照表面的单元格，注入反射radiance信息。然后迭代，修改自身的radiance场。多次迭代收敛。

#### VXGI

[[VXGI]]
VXGI：稀疏体素八叉树存储；注入直接光照；锥形追踪返回一个radiance。

#### SSGI

[[SSGI]]
SSGI：生成Hiz；在表面点构建光线方向；光线步进；时域降噪；双边过滤

### Specular GI：

- 局部环境贴图：反射代理，使用代理中心到交点的连线来所引环境贴图
- VXGI：锥形追踪
- 平面反射：反射定律；变换观察者的位置和观察方向
- SSR：反射方向追踪射线，HiZ

### 降噪

- SVGF
- NRD

## 全局光照算法了解哪些？介绍一下GI，知道哪些GI理论？

全局光照算法的目的是计算直接光照和间接光照效果，其中难点在于计算间接光照效果，但是一次弹射的间接光照就足以产生令人信服的结果。

两种通用全局光照方法：辐射度算法（有限元分析）和光线追踪（蒙特卡洛积分）。

1. 环境光遮蔽：预计算环境光遮蔽，物体空间中的动态环境光遮蔽（圆盘法，近似法，基于符号距离场的方法+锥形追踪法），屏幕空间中的动态环境光遮蔽（SSAO，HBAO，GTAO）
2. 定向遮蔽：SSDO
3. 漫反射全局光照：预计算漫反射全局光照（烘焙），预计算radiance传输（PRT），RSM，LPV，VXGI，SSGI，DDGI
4. 镜面全局光照：局部环境贴图，基于体素的方法（VXGI），平面反射，SSR，光追反射
5. 路径追踪

## RSM是怎么做的？

[[RSM]]

## LPV是怎么做的？

[[LPV]]

## VXGI是怎么做的？

[[VXGI]]

## SSR 是怎么做的？ray Marching 是如何进行的？

[[SSR]]
利用当前帧已经渲染好的屏幕空间信息（主要是深度图、法线图和颜色图），通过在屏幕空间进行光线追踪（Raymarching），来查找反射光线可能击中的像素，从而模拟反射。
给定着色点的位置，观察向量和法线，SSR 会沿着法线反射的观察向量来追踪一根光线，并测试其与深度缓冲的交点。
优点：
- 速度快，效果不错。
缺点
- 屏幕空间中信息不全，可能会出现反射瑕疵。
Ray Marching 光线步进是一种光线求交技术. 每次向光线方向步进一定距离, 检查当前是否和场景相交. Ray Marching 有多种加速方法, 比如 SDF, 或者 Hi-Z, 来帮助我们快速跳过空间中空白区域

## 如果要用在移动端使用全局光照，你觉得哪些 GI 算法优化之后是可行的？

- 移动端的特点：算力尚可，带宽速度严重受限（主要是为了减少发热和省电），缓存性能不好。
1. 基于追踪类的全局光照方法，例如VXGI，SDFGI等，它们需要大量的算力，同时访存随机，对移动端非常不友好，因此不适合移动端使用，或者需要大量优化。
2. 基于预计算的全局光照方法，即各种烘焙光照[^1]，以及PRT等，虽然只支持静态物体，但是对人物角色等进行动态计算也是可以的。开销很低，可以应用于移动端。
3. 基于光照探针的全局光照方法，例如DDGI，可以预计算光线追踪，将其存储在探针中，从而支持静态场景和动态光源。
4. 基于屏幕空间总的方法，例如SSAO、SSGI，整体开销较小，虽然需要消耗一定的带宽，但是在优化之后，应该是可行的。
5. LPV之类的全局光照方法，依赖于场景的空间划分和迭代传播，速度较快，

## LPV，SSGI如果要用在移动端，需要进行哪些方面的优化？

- [[LPV]] 问题是每个光源都要进行计算, 光源数量和体素分辨率, 可以根据性能限制光源数量和分辨率
- SSGI 或者说 SSR 需要使用法线, 深度等信息, 最好还是配合延迟渲染使用. SSGI 频繁读取深度图, 占用带宽以及高昂的采样成本. 
    - 优化方面, 针对采样成本. 可以使用 Hi-Z 或者 SDF 加速,
    - 通过降低计算分辨率, 比如一半的 RT 上执行计算, 性能提升巨大。
        - 注意, 计算完成后，需要将低分辨率的结果“升采样”回全分辨率。不能用简单的线性插值，否则会导致模糊和瑕疵。通常使用**边缘感知的双边滤波**
    - 使用时域降噪。由于我们为了性能而大幅减少了每个像素的光线数量（例如，每像素只发射1条随机方向的光线），单帧的结果会充满噪点。时间滤波通过复用前一帧的渲染结果来平滑当前帧的噪点。运动向量, 重投影
    - 使用屏幕边缘渐隐等

## 你自己也实现过 Cluster Lighting，说说这个策略有什么缺点，存在什么问题？

- 这里的Cluster Lighting指的是对视锥体进行三维划分，形成一个个单元格（cluster），并在这个cluster中记录对其产生影响光源列表，然后在进行着色的时候，查询对应的光源列表来进行着色。
- 优点
    1. 兼容前向着色和延迟着色。
    2. 实现简单，不需要区分半透明物体，不需要z-prepass（可选）
    3. 相对于分块（tile）着色而言，对于相机视角的稳定性更好，且每个光源列表的长度更短。

- 缺点
    1. 需要使用compute shader进行光源划分（也可以使用光栅化光源体积进行实现）。
    2. 由于划分的空间更多，因此内存开销会更大；且光源分布不均匀，缓存一致性会变差（大量随机访存），对于移动端不太友好。
    3. 由于划分的空间更多，且不同cluster中使用不同的光源列表不同，因此处于相同warp的像素会变少，会降低一定的性能表现。

## 你写了IBL，讲讲你IBL的输入是什么？IBL的光照输入是怎样的？

- IBL 的最开始输入通常是一张 HDR 的全景图, 根据映射方式的不同, 可以有经纬度贴图（类似于世界地图的展开方式），球面贴图，立方体贴图（cube map），八面体映射等。
    - **经纬度贴图** 主流 因为它最直观，并且是行业标准
        - 这种贴图将球面环境像世界地图一样展开成一张2D矩形图像。水平轴代表经度（0°到360°），垂直轴代表纬度
        - 直观易懂
        - 存储标准
        - 两极严重扭曲
        - 采样效率低
    - Cubemap 运行时标准
        - 硬件原生致辞
        - 分布均匀
        - 无奇异点
        - 存在接缝问题
        - 内存占用略高
    - 八面体映射 (Octahedral Map)
        - 更好的像素均匀性
        - **无接缝的展开**：展开后的2D贴图是连续的，便于进行卷积（Convolution）等图像处理操作（例如生成IBL所需的漫反射和高光预积分图）。
        - **内存效率高**：相比Cube Map，它的有效像素利用率更高。
        - 无硬件原生支持
        - 实现略复杂
    - 球面贴图, 早期的环境映射技术, 模拟的是一个理想的、无限反射的完美球体所反射出的环境。你看到的是一个圆形区域，包含了正面180度的反射，圆的边缘则包含了来自背后的所有环境信息，并被极度压缩。
        - 实现简单
        - 单张贴图
        - 视角依赖
        - 极度扭曲
        - 基本被淘汰

## IBL的过程？镜面反射部分又是怎么算的？

[[IBL]] 指的是使用图片纹理对场景进行照明, 这种环境贴图通常是从现实世界中的场景中获取的, IBL 的算法如下 (针对镜面反射)

1. 生成或者加载表示环境的纹理贴图。
2. 对于包含反射物的每个像素，计算物体表面位置的法线。
3. 根据观察向量和表面法线，计算反射的观察向量。
4. 使用反射观察向量来计算环境贴图的索引，通过该索引来获取入射radiance。
5. 使用来自环境贴图的入射radiance数据来作为反射方程中的入射radiance。

镜面反射主要包含两种情况，一种是完美的镜面反射，另一种是略显粗糙的glossy反射。对于前者而言，由于只有一个单一的反射方向，因此直接使用原始环境贴图中的数据即可。而对于glossy反射而言，需要对一个波瓣范围内的radiance信息进行采样，可以通过对环境贴图进行预先过滤实现。

怎么生成 IBL 见 [[IBL]] 以及 [[PBR相关面经#介绍一下IBL及其具体实现？]]

## 环境贴图？

我们在计算着色方程的时候，需要知道来自某个方向上的radiance信息，这些信息一般是一个球面函数，将这个球面函数记录在图像中，即环境贴图。一般使用反射观察向量进行索引，贴图中的纹素值代表了该方向上的radiance信息。

## DDGI 是怎么做的

DDGI是一种基于光照探针的GI技术，用于生成漫反射光照。其中光照探针使用八面体映射的方法进行存储。有两种不同形式的DDGI：

1. 基于实时光线追踪：光照探针可以动态移动，使用实时光线追踪来更新探针的几何信息和光照信息。
2. 基于预计算：预计算场景的几何信息，并在运行阶段实时更新光照信息。因此无法移动光照探针。

在进行着色计算的时候，使用着色点周围8个光照探针，并对其中的irradiance信息进行插值。

## 光追，路径追踪能描述一下吗？

[[光线追踪|Ray Tracing]]
1. Ray Casting：使用了View Ray和Shadow Ray两条光线，这计算出来的其实就是光照方程中的直接光照部分。
2. Whitted-style Ray Tracing：在光线投射的基础上，加入光与物体表面的交互，是光线在物体表面沿着反射，折射以及散射方式上继续传播，直到与光源相交。
3. Stochastic Ray Tracing：使用漫反射和高光反射两种分布来描述表面与光线的相互作用，使得原来一束单一的反射光变为围绕一个空间中漫反射或高光反射范围内的积分计算。为了计算积分方程，引入了蒙特卡洛方法。
4. Path tracing：Kajiya统一了渲染方程，并推导出了渲染方程的路径表述形式，使得渲染方程由一个递归的结构，变成一个路径函数的积分，即路径追踪。首先在场景中物体的表面随机产生一些点，然后将这些点和光源以及摄像机链接起来形成一条路径，每个路径就是一个路径函数的随机值。
5. Bidirectional Path Tracing：有相当部分的路径组合由于表面间可能被遮挡而形成无效的路径，对最终光照没有任何贡献。从光源和摄像机两个方向出发，分别经过一定的路径之后，将该两条路径的终点链接起来形成一条完整的路径，这样大大增加了光源的有效贡献。

## SDFGI是怎么做的？

SDFGI的核心使用是使用有向距离场来，进行光追求交的加速, Ray marching，并获取场景交点处的光照信息。SDFGI的流程如下：

1. 构建场景的SDF。
2. 利用SDF来进行光线步进加速，获取交点。
3. 计算光照信息。

## SSAO 和 AO?

环境光遮蔽是指着色点半球范围内的某些方向，可能会被自身物体的其他部分或者场景中的其他物体所遮挡，导致亮度变暗。是反应空间几何关系的一种效果，可以帮助产生深度暗示。

环境光遮蔽可以使用静态的，预计算的方法进行，也可以使用动态的方法实时计算。动态方法分为两大类，分别是在物体空间进行的和在屏幕空间进行的。

物体空间中的动态环境光遮蔽有：圆盘法，近似法，基于符号距离场的方法+锥形追踪法。

屏幕空间中的动态环境光遮蔽有SSAO，HBAO，GTAO等。

## 屏幕空间反射、平面反射？

屏幕空间反射：给定着色点的位置，观察向量和法线，我们可以沿着法线反射的观察向量来追踪一根光线，并测试其与深度缓冲的交点，然后计算反射信息。

平面反射（Planar Reflection）：保持场景表示不变，将观察者的位置和观察方向反射到反射平面的另一侧，然后进行渲染。这种反射操作可以通过对投影矩阵进行修改来实现。

## SSGI是怎么做的？

屏幕空间中的算法：与场景复杂度无关；与屏幕分辨率、重复采样、不连贯读取导致的缓存利用率差有关。

SSR获取specular高频信息，SSGI获取diffuse低频信息，效率较低。

1. 数据准备：渲染参数，变换矩阵，相机buffer
2. 构建加速结构，使用ps生成hiz，存储在不同mipmap层级
3. 光线步进
    1. 准备光线数据，计算坐标，生成切线空间基底
    2. 生成采样方向，均匀→Hinton序列→蓝噪声→半球采样
    3. Hiz光线步进，获取碰撞信息
    4. 处理碰撞信息，对scene color采样，计算漫反射光照
4. 降噪处理
    1. 时域：motion vector重投影；AABB 颜色clamp
    2. 空域：双边过滤，深度和法线作为权重
5. 其他优化：半分辨率追踪；屏幕边缘渐隐

## DDGI

[[DDGI]]

[^1]: 光照贴图 将场景中静态物体的光照信息（包括直接光和间接光）预先计算好，并存储到一张或多张特殊的纹理（即光照贴图/Lightmap）中的技术。在运行时，渲染静态物体时只需额外采样这张贴图，将其颜色与物体本身的材质颜色相乘，即可获得逼真的静态全局光照效果。
    光照探针
    预先计算每个探头位置所接收到的来自四面八方的间接光信息。这些信息通常使用球谐函数 (Spherical Harmonics, SH) 进行编码和存储。运行时的动态物体（如角色）可以通过对周围的几个探头进行采样和插值，来获得一个近似的、与环境相融合的间接光照。
