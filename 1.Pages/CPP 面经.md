---
Type:
  - Page
  - MOC
  - 面经
aliases:
  - C++面经
tags: 
modifiedDate: 2025/06/25, 19:46:28
---

# CPP 面经

## [[虚函数面经]]

## [[类型转换面经]]

## [[类与多态面经]]

## 智能指针

- 介绍一下C++11 中智能指针
    - [[C++智能指针]]
- 介绍一下shared_ptr的底层实现？如何保证会自动析构？
    - [[C++shared_ptr|std::shared_ptr]]
- 智能指针了解吗？讲一下shared_ptr？如何解决循环引用的问题 [C++智能指针](C++智能指针.md) [shared\_ptr](C++shared_ptr.md) [怎么解决](智能指针循环引用.md)
- 智能指针如何实现？[C++智能指针](C++智能指针.md)
- [在多线程环境中，智能指针会出现问题吗？有可能一个指针被析构多次吗？](在多线程环境中，智能指针会出现问题吗？有可能一个指针被析构多次吗？.md)
- 介绍一下shared_ptr线程不安全问题？shared_ptr一定线程安全吗？如何保证多个shared_ptr的读写安全？
    - shared_ptr的引用计数在多线程中的读写是线程安全的（原子操作），这意味着多个线程可以安全地读取和修改引用计数，不需要额外的同步。
    - 但是shared_ptr指向的对象在多线程环境中的写操作是线程不安全的，需要使用额外的同步机制；否则会导致出现竞争问题，从而出现未定义的行为。
    - 读写锁 [[C++shared_mutex]]
        1. 多个读者可以同时读
        2. 写者必须互斥（只允许一个写者写入，也不允许读者写者同时进行）
        3. 写者优先于读者（一旦有写者，则后续读者必须等待，唤醒时优先考虑写者）
    1. 互斥锁,稍慢
        1. 一次只能由一个线程拥有互斥锁，其他线程需要等待。
- 介绍一下 unique_ptr？unique_ptr可以传自定义的析构函数吗？占用额外空间吗？
    - [[C++unique_ptr|std::unique_ptr]]
- weak_ptr是用来解决什么问题的？[智能指针循环引用](智能指针循环引用.md)
- [建议把所有指针都替换成智能指针吗？](建议把所有指针都替换成智能指针吗？.md)
- [如果在项目中禁用智能指针,怎么去做自动内存管理？](如果在项目中禁用智能指针,怎么去做自动内存管理？.md)
- refcount为什么要放在动态内存(堆)里？
    - shared_ptr 需要保存计数信息, 在强引用计数归零前,内存不能释放. 同时为了与 weak_ptr 协作, 在弱引用计数归零前,控制块内存不能释放. 
    - refcount（引用计数）被存储在动态内存中的原因是为了确保在对象销毁时不会丢失引用计数的信息。
    - 当一个对象被销毁的时候，它存储的任何内容也会被销毁；但是，我们不希望丢失引用计数的信息。如果将引用计数存储在栈上，那么对象的副本也会导致引用计数的副本，这将破坏引用计数的目的。
- shared_ptr怎么实现多指针指向同一个地址？
    - shared_ptr会维护一个**控制块**，其中包含原生指针、引用计数等信息，并且这个控制块存储在堆上。
    - 在我们创建shared_ptr的时候，shared_ptr的构造函数会**分配一个新的控制块**并对其进行初始化；当通过拷贝构造或者拷贝赋值，使用现有shared_ptr创建shared_ptr的时候，新shared_ptr会和原有的shared_ptr指向**同一个控制块**，同时控制块的引用计数会增加。
- 引用计数如何保证不同类实例的指针之间共享同步
    - 在shared_ptr中，引用计数的同步是通过原子操作来实现的，从而确保在多线程环境下，对引用计数的操作是线程安全的。
- 循环引用会在什么情况下产生？如何解决？解决的原理？
    - [[智能指针循环引用]]
- 几种智能指针能否隐式初始化？不使用make_shared如何进行初始化？能不能解引用？
    - shared_ptr和unique_ptr可以通过直接使用new关键字进行隐式初始化，并且可以通过解引用操作来访问指向的对象。
    - shared_ptr 和 unique_ptr 可以**默认初始化**, 即指向 nullptr
    - **weak_ptr需要通过shared_ptr**进行初始化，并且需要使用lock()方法获取一个shared_ptr对象后才能进行解引用操作。
- 手写shared_ptr：最基础版本
    - [[C++shared_ptr|std::shared_ptr]]
- 使用make_shared和使用new来创建智能指针，有什么区别？
    1. make_shared
        1. 一次内存分配，同时分配控制块和实际对象的内存资源。
            1. 分配的效率更高
            2. 控制块和分配出来的对象，在内存位置上彼此相连(拥有良好的缓存一致性)，访问也会更快
        2. 更好的异常安全性。如果在对象构造过程中抛出异常，内存会自动释放
    2. 使用new (为了兼容 旧 API)
        1. 如果在new之后，智能指针构造之前抛出异常，那么此时new出来的内存资源可能不会被正确释放
        2. 两次内存分配，先分配实际对象的内存资源，然后再分配控制块的内存资源

## STL

- [[C++ STL]] 是什么, 整体介绍一下c++中的STL？
- 介绍一下STL中的常见容器、常见操作以及复杂度？
    - [[C++ STL#常见容器, 常见操作, 复杂度]]
- [[C++Map|std::map]] 是如何实现的？为什么要使用红黑树？红黑树有什么特点？[std::map](C++Map.md), [红黑树](红黑树.md)
- map和unordered_map的区别？set与unordered_set的区别？
    - 实现原理
        - map 和 set 使用[[红黑树]],键是自动排序的
        - unordered_map 则使用[[哈希表]],不保证顺序
    - 时间复杂度
        - 由于[[红黑树]],map 和 set 平均时间复杂度为 O(logn)
        - 哈希表平均 O(1),在极端情况下(所有元素都在一个桶中)则 O(n)
    - 使用场景
        - map,需要按顺序遍历容器, 需要有序性
        - unordered_map,不需要有序性,优先考虑速度
- map的优点有哪些？
    - 有序性: 按键值进行排序, 遍历时有序
    - 各种操作平均复杂度为 O(logn)
    - 不需要重哈希
- vector的实现原理？vector的扩容机制？
    - [[C++Vector#实现|std::vector实现]]
- vector里加入10万数据，游戏中有对象的指针指向 vector 的元素，这可能有什么问题？
    - 见 [[C++Vector|std::vector]] 实现中扩容的说明
    - 扩容分为 3 步:
        1. 先分配更大的内存空间
        2. 将原始数据拷贝过来
        3. 释放之前的内容
    - 这会导致**指针[^1]和迭代器失效**（string同理）
- vector如何快速删除中间对象？
    - vector内部是顺序存储的，只有删除最后一个原始的时间复杂度为O(1)。
    - 如果对内部数据的顺序没有要求，可以先将要删除的元素与末尾元素swap，然后再使用pop_back直接删除末尾元素即可。
- 刚刚我们聊过vector的扩容，那vector怎么减容？pop_back之后，vector会自动减容嘛？如果不会减容，那我们怎么释放不必要的内存呢？C++是否提供了我们什么接口呢？
    - vector并不会自动减容，在pop_back之后，vector也不会自动减容,只是让尾指针减 1
    - clear 也只是让尾指针移动到头指针位置, 实际分配的内存即 capacity(空间指针)不变
    - 如果想要回收不必要的内存，可以调用函数 `shrink_to_fit`，**请求**容器退回不需要的内存空间。
        - 非强制性请求,意味着标准库的实现**可以选择忽略**这个请求,但通常都会有效地执行内存收缩
        - 迭代器、指针和引用**可能会**全部失效
            - 当容器的 `capacity()` **大于** `size()` 时,会重新分配内存,导致失效
            - 当相等时, 不会
    - 使用 **swap** **清空**内存: 在 C++11 引入 `shrink_to_fit()` 之前，使用 `swap` 是回收 `std::vector` 未使用容量（capacity）的标准做法
        - `std::vector<int>().swap(my_vec);`
        - `std::vector<int>()` 创建一个匿名的、临时的空 `vector`。
        - `my_vec` 与这个临时 `vector` 交换内部状态。
        - 在这行代码（完整表达式）结束时，那个临时的 `vector`（现在持有着 `my_vec` 的旧内存）被销毁，内存被释放。
- vector的push_back的时间复杂度是多少？
    - 平均 O(1)
    - 当没到容量上限的时候：O(1)
    - 到了容量上限的时候：O(n)
- list的实现原理？
    - [[C++List#实现|std::list实现]]
- vector和list的区别？
    - 底层的物理结构不同
        - vector 的是连续内存,是顺序存储
        - list 是非连续的, 是链式存储
    - 数据结构不同
        - vector 是数组
        - list 是[[双向链表]]
    - 操作时间复杂度不同
        - vector,尾插删 O1,中间插删 O(n), 随机访问 O(1)
        - list,插删(给定位置)O(1),访问 O(n)
    - 内存额外开销不同
        - vector 额外三个指针
        - list 一个哨兵节点+一个size(size_t[^2]), 再加上每个元素的额外两个指针, 
- 介绍一下hash表，怎么评判hash函数的好坏？
    - [[哈希表#评估指标]]
- 介绍一下 std::priority_queue?
    - [[C++priority_queue|std::priority_queue]]
- 给定值为1-100的数据块，如何构建vector速度最快？vector和list从头部插入数据谁更快？
    - 在初始化时预留 100 的空间,即 `std::vector<int> vec(100)`
    - 然后依次构造, push_back 或 emplace_back,使用移动语义
    - list更快，因为vector头插需要调整数组内其他元素的位置。
- 介绍一下deque的实现原理？双端队列
    - [[C++Deque#实现|std::deque实现]]
- 介绍 hash_map的实现原理？
    - [[C++Unordered_Map|std::unordered_map]]
- 哪些STL容器的底层是哈希表？
    - 名字前面带unordered的关联容器
    - unordered_map，unordered_set，unordered_multimap，unordered_multiset
- reserve和resize的区别？
    - `reserve()` 只改变容器的**容量（`capacity`）**，不改变元素数量（`size`）。它只和**内存分配**有关。
        - 如果大于当前 capacity,
            `vector` 会重新分配一块更大的内存，其新的 `capacity` 至少为 `n`（具体多大由实现决定）。然后，它会将所有现有元素从旧内存移动到新内存，并释放旧内存。这是一个开销较大的操作。
        - **如果 `n` 小于或等于当前的 `capacity()`**,什么都不做
    - `resize()` 改变容器的**元素数量（`size`）**，并可能会附带改变容量（`capacity`）。它和**真实的元素**有关。
        - 如果 n < size(), 会析构尾部多余的元素,size 变为 n, 不改变容量
        - 如果 n>size(),会在尾部初始化新元素,size 变为 n. 默认使用默认构造函数 
            - 另外如果 `n` 大于当前的 `capacity`,会在添加新元素之前，先进行一次内存重分配, 即先执行 reserve,再 resize
- 介绍一下STL中的顺序适配器？
    - [[C++适配器#例子|Adapter]]
- 给定一个链表的头节点和**要删除的节点**，如何使用O(1)复杂度完成删除操作？
    - **复制内容**：将**要删除节点的下一个节点**的内容，完全复制到**要删除节点**中。
    - **修改链接**：然后，将**要删除节点**的 `next` 指针，指向**下一个节点的下一个节点**。
    - **删除“替身”**：最后，安全地删除那个“下一个节点”，因为它现在已经是一个多余的“替身”了。
    - 或者 `x = B->next; std::swap(*B, *(B->next)); delete x;` 但这样多了一次拷贝
- 如果有500w个数据要取前100大的，如何完成？TopK问题
    - 排序再取,快排, $O(nlogn)$ **太浪费**
    - [[堆排序]],建立大小为 100 的小顶堆,每次移除堆顶最小元素,从而实现保留最大的 100 个,时间复杂度为 O(nlogk),k=100,n=500w
    - std::partial_sort,堆排序后再进行一次排序,得到有序结果
    - [[快速选择]],如 [[159. 库存管理 III]]
- 超大型整数，数据结构如何设计？相加溢出怎么处理？
    - 利用 bitmap 存储每一个 bit 的信息，利用类似vector的变长线性容器来存储bitmap ，在溢出的时候适当延长bitmap 的位数。
- vector<int&>这样写可以吗？容器中为什么不能存储引用类型？
    - **不行，`std::vector<int&>` 这样的写法是无法通过编译的**。
    - 引用并不是一个对象（在内存中不占据实际的空间），只是一个已有对象的别名，因此无法定义一个指向引用的指针（指向内存中的某一片区域）。
    - 当容器中存储引用的时候，例如int&，那么指针和迭代器的类型会变成 `int&*`，这种类型的非法的。
- 有指针了为什么还要迭代器？
    - 迭代器用于提供一种**统一的方法**，来顺序访问一个容器中的各个元素，而**不需要暴露该元素的内部表示**。
    - 迭代器本身不是指针，而是类模板。它模拟了一些指针的功能，是对原生指针的封装，可以根据不同类型的容器对象，类实现不同的重载操作符。
- 对于vector来说，迭代器什么时候会失效？
    - 即内存发生变化时
    - 发生在:
        - 插入元素
            - 导致capacity增加：所有迭代器均失效
            - capacity不增加：插入点之后的迭代器均失效
        - 删除元素
            1. 被删除元素及后面的迭代器均失效
            2. 如果是通过erase进行删除的，则会返回第一个有效的迭代器
        - 扩容或缩减: 当 capacity 变化时,全部失效
- 对于STL容器，如何删除中间的某个元素？
    1. 顺序容器（vector，deque）
        1. erase会使得当前迭代器失效，同时会使得之后所有的迭代器都失效。因此不能使用erase(it++)的方式来删除元素。
        2. erase的返回值是下一个有效的迭代器，因此可以使用it=erase(it)
    2. 关联容器
        1. erase只会使得当前迭代器失效，不会影响其他的迭代器，返回值是void，因此使用erase(it++)的方式来删除元素。

## 指针与引用

- 指针和引用的区别？
    - [[C++引用]]
    - [[C++指针]]
    1. 指针可以有多重指针，而引用只能有一级。因为引用并不是一个对象，而引用必须与对象绑定在一起。
    2. 指针在初始化的时候可以不指定初始值，而引用在初始化的时候必须绑定初始值。
    3. 指针指向的对象可以修改, 引用在初始化后不能更改引用的对象
    4. 对指针进行sizeof，得到的是指针本身的大小；对引用进行sizeof，得到的绑定对象的大小。
    5. 当将指针作为参数传递的时候，实际上是拷贝一个新的指针；而引用则不是。
    - 对编译器来说
        - 指针：指针的内容是所指向内存的地址，在编译的时候会将“指针变量-指针变量的地址（而不是所指对象的地址）”添加到符号表中，因此指针中所包含的内容是可以修改的，允许拷贝和赋值。
         ==所以指针需要两次取内存==
        - 引用：引用是内存的别名，在编译的时候会将“引用变量名-引用对象的地址”添加到符号表中。符号表一经完成不能进行修改，因此引用必须在定义的时候被绑定到内存中，后续也不能进行修改。
          ==引用只需要一次取内存==
- 指针常量和常量指针，底层const和顶层const？
    - [[C++顶层Const和底层Const]]
    - 常量指针
        - `int *const p` 
        - 是顶层 const
        - 指自身不可变, 指针内存储的地址不可变
    - 指针常量(指向常量的指针)
        - 指针指向的对象是一个常量
        - `const int *p`
- 左值和右值分别是什么？说一下左值右值？
    - [[左值与右值]]
    1. 含义不同：左值表示的是对象的身份，而右值表达的是对象的值。
    2. 存储不同：左值具有内存地址，右值没有具体的内存地址。
    3. 生命周期不同：左值在表达式结束之后仍然存在，右值在表达式结束之后就消失了。
    4. 可修改性不同：左值可以被修改赋值，右值不能被修改赋值。
- 移动语义和完美转发是什么？右值引用与移动构造？
    - [[右值引用与移动语义]] [[C++完美转发]] [[C++构造函数#移动构造函数]]
- std::move的实现原理？std::move的作用是什么？
    - [[C++Move|std::move]]
- 引用折叠是什么
    - 在间接创建引用的引用时，引用会进行折叠。**只有右值引用的右值引用会被折叠成右值引用**，其他情况都会被折叠成左值引用。
        - X& &，X& &&，X&& &都会折叠成X&
        - X&& &&会被折叠成X&&
    - 引用折叠的作用：
        1. 如果函数参数是右值引用（&&），那么它可以被绑定到一个左值上，也可以绑定到一个右值引用，即可以传递给它任意类型的实参。
        2. 如果函数参数是左值引用（&），那么会被折叠成左值引用。
- 什么是无效引用？
    - 无效引用是指在使用引用的时候，引用的目标对象不存在或者已失效的情况。当我们尝试使用一个无效引用的时候，可能会导致程序崩溃、未定义的行为或其他错误。
    - 无效引用可能出现在以下情况下：
    1. 引用空指针：当我们将一个空指针赋值给一个引用时，该引用就成为了一个无效引用。因为空指针并没有指向有效的对象。
    2. 引用已销毁的对象：当一个对象的生命周期结束后，如果我们仍然尝试使用对该对象的引用，那么该引用就成为了一个无效引用。因为该对象已经被销毁，引用指向的内存区域可能已经被释放。
    3. 引用超出作用域：当一个引用超出了其定义所在的作用域时，该引用也会成为一个无效引用。因为引用只在其定义的作用域内有效，一旦超出该作用域，引用就无法访问到有效的对象。
    - 为了避免无效引用的问题，我们应该注意以下几点：
        - 在使用引用之前，确保引用的目标对象存在且有效。
        - 在使用引用之前，检查引用是否为空指针。
        - 在引用超出作用域之后，确保不再使用该引用。
- i++和++i的区别？
    - ++i, i 会自增,然后返回改变后的对象, 不会产生临时对象

      ```cpp
        int& int::operator++ ()
        { 
            *this +=1;
            return *this;
        }
      ```

    - i++需要将原始值存储下来，然后将i自增1，最后再返回原始值。由于引入了临时对象，因此会使得效率降低。

      ```cpp
        const int int::operator（int）
        {
             int oldValue = *this;
             ++（*this）; 
             return oldValue; 
         }
      ```

- 野指针是什么？产生原因是什么？怎么解决？
    - [[C++野指针]]
- std::forward的实现原理？std::forward的作用是什么？
    - [[C++完美转发]]
- emplace_back和push_back的区别？
    - push_back 在向容器尾部添加元素的时候，会先在外部构造一个对象,然后使用拷贝构造或者移动构造(如果可用)添加, 适用于已有对象
    - emplace_back 需要提供对象的构造参数, 然后直接在 vector 所管理的内存原地构造一个对象. 
    - emplace_back 相比于 push_back 减少了临时对象的开销, 也就是一次构造函数
- `void *` 有什么用处？
    - `void *`：特殊的指针类型，可用存放任意对象的地址；我们无法直接操作 `void*` 所指向的对象。
    1. 处理多种数据类型的函数参数：使用 `void*` 作为函数参数类型，可以接受任意类型的指针作为参数。这样的函数可以处理不同类型的数据，提高了代码的灵活性和可重用性。
    2. 内存管理：`void *` 可以用于动态内存分配和释放。例如，使用malloc函数分配内存时，返回的指针类型是 `void *`，可以根据需要进行类型转换，然后使用分配的内存。
    3. 泛型编程：`void *` 在实现泛型编程时非常有用。通过使用 `void *`，可以编写与特定数据类型无关的代码，从而实现更通用和灵活的算法和数据结构。
    4. 函数返回值的灵活性：当函数的返回值类型不确定时，可以使用 `void *` 作为返回类型。这样的函数可以返回任意类型的指针，调用者可以根据需要进行类型转换。
    5. 与C语言兼容性：`void *` 在C和C++中都是有效的类型。使用 `void *` 可以方便地与C语言代码进行交互和调用。
- 如果函数模板中定义了static局部变量，那么会有几个static局部变量的副本？
    - 函数模板会根据不同的模板参数特化生成不同的模板函数
    - 每一个模板函数中的静态局部变量只被初始化一次
    - 因此，函数模板被特化了n次，就会有n个static局部变量。
- 野指针和内存泄漏的区别？
    - 野指针：指向无效（未定义）内存地址的指针
    - 内存泄露: 没有正确释放内存, 失去了对一块内存的控制权, 造成内存浪费. 如果持续泄露会导致崩溃
- 介绍一下c++中的指针传参和引用传参？以及他们的区别？
    - 指针传参：指针传参本质上还是值传递，它所传递的是⼀个地址值。在值传递的过程中，被调函数的形参作为函数的局部变量进行处理，会在栈中开辟内存空间以存放传递进来的实参值，从而构造了实参的⼀个拷贝副本。值传递的特点是，函数对形参的任何操作都是作为局部变量进行的，不会影响实参的值（形参指针变了，实参指针不会变）。
    - 引用传参：形参也作为局部变量在栈中开辟了内存空间，但是这时存放的是实参变量的地址。被调函数对形参（本体）的任何操作都被处理成间接寻址，即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到对应的本体）。因此，函数对形参的任何操作都会影响主调函数中的实参。
    - 指针传参和引用传参的相同点：都是栈空间中的局部变量
    - 指针传参和引用传参的不同点：
        - 在指针传参中，我们无法修改原始指针中存储的地址值，但是可以对原始指针所指向的对象进行修改。
        - 在引用传参中，会通过间接寻址的方式，直接对原始变量进行操作。
    - [[C++指针]]
- 野 (wild)指针与悬垂(dangling)指针有什么区别？如何避免？
    - [[C++野指针|野指针]]：没有被初始化或指向无效区域的指针，所指向内存区域中的内容是未定义的。
    - [[C++垂悬指针]]: 指向的内存空间已被释放或不再有效
- 介绍一下函数指针？
    - 函数指针本身是一个指针类型的变量，其中存储的是具体函数的地址。
    - 在编译的时候，每个函数都有一个入口地址，这个地址就是函数指针所指向的地址。通过函数指针，我们可以直接调用函数。
    - 常见的用途是：将函数指针作为形参，用于执行某些回调函数。
    - 推荐使用 [[std_function|std::function]]
- 介绍一下函数参数传递的几种方式？
    1. 值传递：形参是实参的拷贝，会调用拷贝构造函数；对形参的操作不会影响外部的实参。
    2. 指针传递：本质上也是值传递，拷贝的是指针对象本身，可以对指针所指向的对象进行操作，从而影响外部实参
    3. 引用传递：将引用对象的地址放置在栈空间中，对形参的任何操作，都是直接作用于外部实参的。
- this指针
    - 成员函数时会隐式传入一个参数(static 没有)， 这个参数就是this指针。this指针中存放的就是这个对象的首地址。
    - 编译器在生成程序时加入了获取对象首地址的相关代码。并把获取的首地址存放在了寄存器ECX中(VC++编译器是放在ECX中，其它编译器有可能不同)。也就是成员函数的其它参数正常都是存放在栈中。而this指针参数则是存放在寄存器中。
- 引用占内存吗
    - 指针和引用(别名)本质上是不同的, 但编译器不优化的情况下通常将其实现为常量指针
    - 如果开启了优化, 引用就真的是别名,相当于直接访问原对象,此时引用不占内存
    - 而使用指针需要解引用, 多一次寻址(如果优化了也只用访问一次)
    - 但是对于类中存储引用的情况, 编译器必须有一种物理上的方式来存储这个“别名”关系。编译器最直接、最常见的实现方式就是使用一个指针来存储这个引用。这是优化不掉的.
- 区分一下类型：指针、数组等

    ```cpp
    int *p[10];
    int (*p)[10];
    int *p(int);
    int (*p)(int)
    ```

    - 指针数组：一个包含10个元素的数组，其中每个元素都是一个指向int的指针
    - 声明了一个int数组，包含10个元素。p是一个指针，指向这个int数组的首地址
    - 函数声明：输入为int，返回int*
    - 函数指针：p是一个**函数指针**，指向一个函数，这个函数的输入和返回值都是int
- 如果返回一个局部变量的引用会发生什么？
    - 很可能会发生 UB,一旦函数执行完毕，其对应的栈帧就会被销毁，局部变量所占据的内存空间也随之失效。任何尝试通过这个悬空引用去访问或修改它所指向的内存，都会触发未定义行为。未定义行为的后果是不可预测的. 
- 如果有一个结构体 A，结构体内部保存一个结构体 B 的引用，结构体 B 的 size 是 64 字节。sizeof(A)会是多少？[C++引用](C++引用.md)

## 编译链接

- 介绍一下程序编译的各个过程？从 cpp 源代码到 exe 经过了哪些过程？
    - [[C++程序编译流程]]
    - [[HLSL 编译流程]] [[SPRIV 编译流程]]
- 编译阶段之前有没有要做的？
    - 编译阶段之前是预处理阶段。包括去除所有 `#define`, 替换各种宏, 处理各种条件编译指令, `#if`, 处理所有 `#include`, 将文本内容替换到对应位置。删除注释, 保留 `#pragma`, 添加行号和文件标识, 帮助编译器产生调试使用的行号信息, 最后得到 `.i` 文件
- 如何在main函数之前执行一段代码？
    - 参考 [[C++程序入口]], C++的默认入口是 Main(), 但在此之前, 会先进行全局变量和静态变量的初始化, 设置 IO 流, 以及其它必要的启动代码,然后才是 main 函数
    - 所以, 我们可以定义一个全局对象, 在这个全局对象的构造函数中执行我们需要的代码
    - 其它就是一些依赖于平台或者编译器的方法:
        - 比如在 GCC 编译器中, 可以在函数前加上__attribute__((constructor))属性；代表这个函数需要在main函数之前执行。
        - Windows 上使用 `#pragma section` + `__declspec(allocate(...))`
- main函数执行之前会做些什么？
    - [[C++程序运行]]
    - 设置栈指针
    - 初始化 static 和 global 变量, [[C++内存区域]]的 data 段
    - 将未初始化的全局变量和静态变量赋初值, .bss 段
        - 数值型short，int，long等为0
        - bool 为 false, 指针为 null 等
    - 将main函数的参数argc，argv等传递给main函数，然后才真正运行main函数
- main函数执行结束之后会做些什么？
    1. 执行全局对象的析构函数
    2. 可以用 **atexit** 注册一个函数，它会在main 之后执行
    3. `__attribute__((destructor))`
- c++的函数入口和启动代码？
    - C++函数的入口点通常是main函数。这是因为C++语言规范规定了程序的执行从main函数开始。
    - 在C++程序执行之前，会有一些**启动代码**（start up code）负责设置程序的运行环境，并调用main函数来开始程序的执行。
- 静态库和动态库的区别是什么？
    - [[C++静态库和动态库]]
-  程序的真正入口是 main 函数吗？如何让程序以任意函数为起点？[C++程序入口](C++程序入口.md)

## 内存

- new和malloc有什么区别？delete和free有什么区别？
    - malloc和free是标准库函数，支持覆盖；new和delete是运算符，支持重载
    - malloc仅仅分配内存空间，free仅仅回收空间；new和delete多了调用构造函数和析构函数功能
    - malloc和free返回的是 `void*` 类型指针（必须进行类型转换），new和delete返回的是具体类型指针。
- C++ 堆内存与栈内存之间的区别是什么？[C++内存区域](C++内存区域.md)
- new是怎么实现的？
    - [[C++new]]
- delete如何知道需要释放多少内存的？
    - 在使用new分配内存的时候，通常会比请求的内存多一点，用于存储头部信息。
    - 头部信息记录了分配的内存块的大小，delete在释放内存的时候，会先找到这些头部信息，然后再正确的释放整个块。
- c++中有哪些类型的new？
    - [[C++new#类型]]
- [[C++allocator]]是什么？简单介绍一下？
- new 的时候发生了什么
    - [[C++new#实现]]
- 介绍一下C++对象内存布局？内存分区有哪些? 堆栈有哪些区别？
    - [C++内存区域](C++内存区域.md)
- 平时遇到内存泄漏，怎么排查的，野指针呢，数组越界呢？
    - 定义
        - [[C++野指针]]
        - 内存泄露指 堆上的内存没有正确释放, 失去对其控制, 造成内存浪费. 如果一直泄露, 进程占用内存会持续变大, 直到用尽操作系统内存, 然后崩溃
    - 怎么排查
        - Windows下可以使用CRT库
            - 微软 **C 运行时库 (C Runtime Library, CRT)** 的一部分。
            - C/C++ 程序在 Windows 操作系统上运行所必需的基础库。它提供了 C/C++ 标准库函数的实现（如 `printf`, `malloc`, `strcpy` 等）以及许多平台特定的功能。
            - **用法**: 
                - 在代码开头包含 `<crtdbg.h>`，并在程序退出前调用 `_CrtDumpMemoryLeaks();`。
                - 以“调试”模式运行程序，当程序结束时，泄漏信息会输出到“输出”窗口，双击即可跳转到分配内存的代码行。
        - 使用其他一些调试工具，来查看可用内存是否会持续减少
    - 怎么避免
        - 保证new和delete成对出现
        - 尽量使用智能指针
        - 针对多态类, 将基类的析构函数声明为虚函数
- new出来的对象内存如果不回收会怎样？
    - 程序性能下降：内存泄漏会导致系统的可用内存逐渐减少，当可用内存不足时，系统可能会频繁进行内存交换，导致程序性能下降。
    - 程序崩溃：如果内存泄漏严重，最终可能导致程序崩溃，无法正常运行。
- 类对象大小问题？64 位系统下,指针 8B
    - 空类 1B
    - 一个 int 的类 4B
    - 一个 int(4) 和 double(8) 4+8+4(对齐) 的类为16B [[C++内存对齐]]
    - 虚函数, 添加一个虚表指针(8B)
    - 虚继承和多虚继承, 1 个虚基类指针 见[[#^2f972a|一个类在各种情况下取sizeof()的结果？]]
    - 多继承, n 个虚表指针
    - 多继承,虚继承(解决菱形引用),n 个虚基类指针＋n 个虚表指针(如果有虚函数)
    - 静态变量不占据类对象的大小，静态变量位于全局静态存储区。
    - 类最后大小还需要进行对齐[[C++内存对齐]]
- 定义一个struct，有int x，char c两个成员，这个结构体的大小？如果增加一个static int 这个结构体大小怎么变化？ 如果在结构体里定义一个虚函数，结构体大小怎么变化？**64 位系统**
    - 有 int x，char c 两个成员: 8B
    - 增加一个 static int : 8B. static对象不占据类对象的空间，它位于在全局静态存储区。
    - 如果在结构体里定义一个虚函数: 16B.  虚表指针 8B
- 为什么要进行内存对齐
    - 内存对齐是为了提高访问性能。CPU在读取内存的时候会**按块进行读取**。当访问未对齐的数据时，处理器需要进行**额外的操作**来获取数据，这会导致性能下降。
    - 通过对齐数据，可以使处理器能够以更高效的方式访问数据，从而提高程序的执行效率。例如**SIMD指令**，会同时处理多个数据元素，如果没有内存对齐，可能就无法同时加载到SIMD寄存器中，从而导致额外的内存访问、数据拷贝等操作。
    - 一些硬件设备(GPU)和操作系统对于特定类型的数据有对齐要求，不满足对齐要求可能会导致硬件错误或异常。因此，内存对齐还可能是为了确保数据的正确性和可靠性。
- 内存对齐会带来哪些问题？
    - [[C++内存对齐#问题]] 
- 如何不申请内存空间只调用构造函数？
    - 正常的new会分配内存，并调用构造函数
    - 使用placement new可以实现不分配内存，只调用构造函数。**即传入一个已经存在的指针**，然后进行原地构造。	`void* ptr = malloc(4); int* p = new(ptr)int(4);`
- 介绍一下讲一下C++对象的生命周期？
    - 对象可分为全局对象, 静态对象, 局部对象, 堆上分配的对象(new)
    - 全局对象在main函数开始之前进行构造，在main函数退出之后销毁。
    - 静态对象在第一次进入作用域时创建，在main函数退出之后销毁。
        - 类的静态成员都在编译时初始化,
        - 普通静态, 在 C++17 前必须在 cpp 中初始化, 且只能出现一次, 
            - 该限制由 [[C++17新特性]]引入的 inline static 解决
            - 可以在头文件中直接进行初始化, 简化了头文件-源文件的管理。
    - 局部对象在进入作用域时创建，在退出作用域时销毁。
    - new创建的对象会一直存在（即使指针已经被销毁，直到 delete, 析构并回收. 对象会一直存在到程序退出。
- 烟花随机绽放的游戏，内存上存在什么问题？
    - 烟花属于数量大、单个内存占用小的对象。
    - 可能会导致内存碎片造成性能下降。
- int 几字节？不同 CPU 架构下大小会变吗？长整型呢？
    - int在32位和64位下为4字节，且int类型保证最少有2字节。
    - long在32位下位4字节，在64位下为8字节，且long类型保证最少有4字节。
    - ![[assets/38b604185e6505b82526c2868b151b5e.png]]
    - ==为了编写需要确切位数的、高度可移植的代码，强烈建议使用C++11引入的头文件 `<cstdint>` 中定义的类型，例如 `int8_t`, `uint32_t`, `int64_t` 等。==[^3]
- 32位浮点数的结构？符合 IEEE754 标准
    - 浮点数的结构由符号位（S）、指数位（E）、有效数位（M）组成。
    - 32位浮点数分别是：1，8，23bit (+1)
- 64 浮点数的结构
    -  **符号位 (S)**: 1 位。
    - **指数 (E)**: 11 位。可以表示的范围是 0 到 2047。偏移量是 **1023**。实际的指数值是 `E - 1023`。
    - **尾数 (M)**: 52 位。加上隐藏的 `1`[^4]，实际精度是 53 位。
- memcpy和memmove的区别？
    - 二者都是完成内存的拷贝任务，区别在于：
    - 当我们使用**memmove**函数时，**memmove**函数其实已经帮我们考虑到了缓冲区是否重叠的问题了，它允许我们把一个字符串内的内容向它自己进行拷贝。
    - 而**memcpy**不会对于重叠的情况加以区别。
    - 使用**memmove**更加安全。
- vulkan 内存对齐
    - 参考 [[C++内存对齐]]
    - GPU 是一块块读取内存的,比如是 16B
    - 这就需要在 CPU 保证传输的数据元素都是 16B 的倍数
        - 结构体内, 每组成员的起始地址要与 16 对齐. 
        - 不能单独的在两个 vec4 中插入一个 int
- memcpy和memmove的区别？
    - 二者都是完成内存的拷贝任务，区别在于：
    - **`memcpy` (Memory Copy)**: 一个用于从源地址拷贝指定字节数到目标地址的函数。它有一个严格的前提条件：**源内存区域和目标内存区域不能有任何重叠**。如果发生重叠，其行为是**未定义 (Undefined Behavior)** 的。
    - **`memmove` (Memory Move)**: 一个同样用于从源地址拷贝指定字节数到目标地址的函数。与 `memcpy` 不同，它被设计为**可以正确处理源和目标内存区域重叠的情况**，保证拷贝结果的正确性。
    - `memmove` 比 `memcpy` 更安全，因为它能正确处理**内存区域重叠**的情况；而 `memcpy` 在这种情况下行为是未定义的，可能会导致数据损坏。
    - **理论上**: `memcpy` 可能比 `memmove` 稍快一点，因为它省去了检查内存是否重叠的步骤。**如果你不确定，或者想编写绝对安全的代码，请使用 `memmove`。** 安全性带来的微小性能开销，远比数据损坏和未定义行为的风险要值得。
- memcpy的底层实现？
    - [[C++memcpy]]
- 动态内存管理的方法？
    1. 使用malloc函数申请内存，使用free函数释放内存
    2. 使用new申请内存，使用delete释放内存
    3. 使用allocator来分配内存。
- 对象实例化的方式和区别？
    - `A a;` a存在栈上
    - `A *a = new A()`  指针 a 指向的对象分配在堆上
    - 前者在离开作用域的时候自动释放，后者在离开作用域的时候不会自动释放，需要自行管理内存。
- 虚拟内存是什么？作用是什么？
    - [[虚拟内存]]
- 详细说一下堆栈内存的区别？
    1. 管理方式不同
        1. 栈内存有静态分配和动态分配。其中静态分配由编译器自动管理；动态分配由allocator函数分配。栈空间的回收释放由编译器自动完成。
        2. 堆内存全是动态分配，由程序员控制，或者使用智能指针进行管理。
    2. 空间大小不同
        1. 栈空间一般为几个M，连续空间
        2. 堆空间一般为几个G（32位下是4G），不连续内存
    3. 增长方向不同
        1. 栈空间向低地址方向增长（高到低）
        2. 堆空间向高地址方向增长（低到高）
    4. 内存碎片问题
        1. 栈内存不会产生内存碎片
        2. 堆内存，频繁的new/delete会造成大量碎片，使程序效率降低
    5. 分配效率问题
        1. 栈内存的分配效率很高
        2. 堆内存的分配机制复杂，效率比栈内存低。
    6. 申请机制不同
        1. 只要栈的剩余空间足够，系统会为程序分配内存，否则会抛出栈溢出的异常。
        2. 对于堆内存。系统中有一个记录空闲内存地址的链表，当系统收到程序内存分配申请时，对该链表进行遍历，寻找第一个空间大于申请空间的堆结点，删除空闲结点链表中的该结点，并将该结点空间分配给程序（大多数系统会在这块内存空间首地址记录本次分配的大小，这样delete才能正确释放本内存空间，另外系统会将多余的部分重新放入空闲链表中。
- 介绍一下malloc的实现原理？
    - 前置知识:
        1. 虚拟内存地址和物理内存地址
            1. 在机器语言层面上使用的都是固定大小的连续虚拟内存
            2. 会使用MMU硬件将其转换为物理内存
        2. 内存页
            1. 虚拟内存和物理内存都是使用页为单位进行管理，典型的页大小为4字节，页内偏移使用低12位进行标识，高位代表了页号
            2. 如果发现某个页缺失了，会触发缺页异常，会到磁盘的相应位置酱磁盘页加载到内存中，然后重新执行指令。
        3. brk和sbrk
            1. 想要增加一个进程实际可用的堆大小，需要将break指针向高地址移动。
            2. brk将break指针直接设置为某个地址
            3. sbrk将break指针从当前位置移动某个增量。
            4. 如果每次申请内存，都调用这些系统指令，会产生系统调用的开销
    - 实现:
      将内存分成大小不同的chunk，将大小相似的chunk使用双向链表链接起来，称为一个bin。根据申请内存大小的不同，采取不同的措施。
        - 内存池管理
            - 操作系统通过 `brk/sbrk` 或 `mmap` 系统调用向进程分配较大块的内存。
            - 这些大块内存被划分为多个小的“块”（chunk），用于满足不同大小的 `malloc` 请求。
        - 对于小对象 **fast bins**
            - 对于小于一定大小（如 64 字节或 128 字节）的申请，会使用预先管理好的“快速分配器”（如 fast bins）来快速返回内存。
            - 这些机制会使用单向链表或数组缓存已释放的小块内存，避免频繁的系统调用。
        - 对于大对象, **large bins**
            - 对于较大的内存块（如几百 KB 或以上），通常会使用 `mmap` 单独申请一块内存，而不是从堆上划分。
            - 这些块的管理会额外记录元信息，以支持释放、合并等操作。
        - 元数据管理（chunk header）
            - 每一块分配的内存，前面通常会有一个“头部”（chunk header），用于记录该块的大小、是否已分配等信息。
            - 用户实际可用的地址位于这个头部之后。
        - 合并与分割
            - `malloc` 为提高利用率，会尝试将相邻的空闲块合并（释放时）或将大块拆分为更小块（分配时）。
- 函数实参的压栈顺序是什么？
    1. 函数的返回地址
    2. 函数的参数从右到左依次入栈
    3. 局部变量依次入栈
- c++中的常量存储在内存中的哪个位置？
    1. 局部常量：存储在栈内存
    2. 全局常量：存储在全局常量区
    3. 字面值常量：存储在全局常量区 [[C++内存区域]]
- 如何让一个类只能静态分配（创建在栈上），或者是只能动态分配（创建在堆上）
    - 只能静态分配：
        - 将new和delete操作符重载为private，外部就无法显式调用, 构造堆上的对象
    - 只能动态分配：
        - 将所有构造函数设为private
        - 自定义两个static函数来执行构造和析构

## 设计模式

- 介绍一下常见的设计模式？以及他们的应用场景？
    - [[设计模式]]

## 并行编程

- 了解并行编程吗？线程与进程的区别是什么？线程之间的通信方式有哪些？[线程](线程.md), [进程](进程.md), [线程和进程的区别](线程和进程的区别.md)
- 线程同步有哪些方式
    1. 互斥锁（Mutex）：互斥锁用于保护临界区，确保在同一时间只有一个线程可以访问某个共享资源。当一个线程获得互斥锁时，其他线程必须等待该线程释放锁才能继续执行。
        1. [[C++shared_mutex]]
    2. 条件变量（Condition Variable）：条件变量用于线程之间的等待和通知。当一个线程需要等待某个条件满足时，可以通过条件变量进入等待状态，而其他线程可以通过条件变量发送信号来通知等待的线程条件已经满足。
    3. 信号量（Semaphore）：信号量用于控制对资源的访问数量。它可以用来限制同时访问某个资源的线程数量，并提供了信号量的加减操作来实现线程之间的同步。[[C++20新特性]]
    4. 屏障（Barrier）：屏障用于让多个线程在一个点上等待，直到所有线程都到达该点后才继续执行。屏障可以用来协调多个线程的操作，确保它们在某个阶段都执行完成后再进行下一步操作。
- 有没有无锁线程同步方式？
    - 有一种无锁线程同步方式称为无锁编程（Lock-free Programming）
    - 无锁编程通过使用**原子操作**和无锁数据结构来实现线程之间的同步，避免使用显式的锁。无锁编程通常需要使用特殊的算法和数据结构，如**CAS**[^5]（Compare-and-Swap）操作和无锁队列等。这种方式可以提高并发性能，但也更加复杂和容易出错，需要仔细考虑并发访问的情况和正确性保证。因此，无锁编程一般适用于特定的并发场景，而不是通用的线程同步方式。
- 多线程中的锁有哪些？分别有什么区别呢？
    1. 互斥锁：互斥锁属于sleep-waiting类型的锁。例如在一个双核的机器上有两个线程A和B，它们分别运行在core 0和core 1上。假设线程A想要通过pthread_mutex_lock操作去得到一个临界区的锁，而此时这个锁正被线程B所持有，那么线程A就会被阻塞，此时会通过上下文切换将线程A置于等待队列中，此时core 0 就可以运行其他的任务（如线程C）。
    2. 自旋锁
        1. 自旋锁属于busy-waiting类型的锁，如果线程A是使用pthread_spin_lock操作去请求锁，如果自旋锁已经被线程B所持有，那么线程A就会一直在core 0上进行忙等待并不停的进行锁请求，检查该自旋锁是否已经被线程B释放，直到得到这个锁为止。因为自旋锁不会引起调用者睡眠，所以自旋锁的效率远高于互斥锁。
        2. 虽然它的效率比互斥锁高，但是它也有些不足之处：自旋锁一直占用CPU，在未获得锁的情况下，一直进行自旋，所以占用着CPU，如果不能在很短的时间内获得锁，无疑会使CPU效率降低。在用自旋锁时有可能造成死锁，当递归调用时有可能造成死锁。
    3. 读写锁：
        1. 多个读者可以同时读
        2. 同时只允许一个写
        3. 写优先于读
- c++中的锁有哪些？
    1. mutex
        1. 基本的互斥锁，同一时刻只有一个线程可以访问被保护的代码块
    2. recursive_mutex
        1. 允许一个线程多次获得同一个互斥锁，而不会导致死锁
        2. 在递归的时候很有用
    3. timed_mutex
        1. 支持超时的互斥锁
        2. 允许线程在尝试获取锁时指定一个超时时间
    4. shared_mutex
        1. 读写锁
        2. 多读单写
- 逻辑地址，物理地址，虚拟地址分别是什么？
    1. 物理地址：它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元真正的地址。
    2. 逻辑地址：是指计算机用户看到的地址。例如：当创建一个长度为 100 的整型数组时，操作系统返回一个逻辑上的连续空间：指针指向数组第一个元素的内存地址。由于整型元素的大小为 4 个字节，故第二个元素的地址时起始地址加 4，以此类推。事实上，逻辑地址并不一定是元素存储的真实地址，即数组元素的物理地址（在内存条中所处的位置），并非是连续的，只是操作系统通过地址映射，将逻辑地址映射成连续的，这样更符合人们的直观思维。
    3. 虚拟内存：是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。
- 内存数据淘汰策略有哪些？
    - LRU缓存策略：LRU（Least Recently Used）是一种常见的缓存淘汰策略，它根据数据的访问模式来决定何时从缓存中淘汰数据。LRU策略假设最近被访问的数据在未来也可能被再次访问，因此淘汰最近最少被使用的数据，以腾出缓存空间给新的数据。这种策略通常可以提高缓存命中率，以提高系统性能。
    - 先进先出（FIFO）：FIFO策略按照数据进入缓存的顺序来淘汰数据。即最早进入缓存的数据先被淘汰。这种策略简单直观，但可能导致缓存命中率低。
    - 最不经常使用（LFU）：LFU策略根据数据被访问的频率来决定淘汰数据。即最不经常被使用的数据先被淘汰。这种策略假设不经常被使用的数据在未来也不太可能被使用，因此将其淘汰。(不限时间, LRU 是限定时间)

## [[C++关键字面经]]

## 其它

- 有一个函数A有很多return，怎么在无论从哪里返回的情况下都调用函数B？
    - 利用局部对象的自动析构机制
        - 创建局部对象，重载析构函数
        - 在函数A中创建一个局部对象，该对象的析构函数中调用函数B。
        - 这样，无论从函数A的哪个return语句处返回，当离开函数A的作用域时，该局部对象将被销毁，从而触发析构函数的调用，进而调用函数B
    - 更复杂一点, 用 B 函数封装 A 函数
- 介绍一下模板的工作原理？
    - 在编译期，编译器根据使用模板的地方所传递的具体类型，生成对应的代码。这个过程被称为模板的实例化。
    - 模板有模板函数和模板类。编译器根据传递的类型参数，生成对应的函数或类的实例。这意味着我们可以使用相同的模板代码来处理不同类型的数据，而无需为每种类型编写独立的代码。
- 介绍一下函数调用的过程？
    1. 参数传递：将实参传递给被调用函数，参数通常放在栈上，从右往左依次入栈
    2. 创建栈帧：栈帧用于存储函数调用期间的局部变量、返回地址、函数参数和其他信息，是一块内存空间
    3. 跳转到被调用函数：一旦栈帧建立完成，程序的控制流将会跳转到被调用函数的起始位置，开始执行被调用函数的代码。
    4. 函数执行和返回：被调用函数将按照其定义的逻辑执行。当函数执行完成后，它会将返回值（如果有）放置在预定的寄存器中（或者内存），并将控制流返回到调用函数的地址。
    5. 栈帧的销毁：一旦被调用函数执行完成并返回，它的栈帧将会被销毁，恢复到调用函数的栈帧状态。这意味着局部变量和函数参数所占用的内存将会被释放。
- 如果函数声明和定义都在头文件，如何避免重复声明和重定义的错误？
    - 对于重定义:
        - 当函数的声明和定义都写在头文件中，如果**多个源文件（.cpp）`#include` 同一个头文件**，就可能导致**函数被多次定义（重定义）**，从而引发**链接错误**。
        - 使用 `inline` 不只是提示编译器做内联优化，更重要的是允许在多个翻译单元中定义函数，而不会引发重定义链接错误
        - 分离声明和定义, 定义放 CPP
        - 使用函数模板重写
    - 对于重复声明
        - 使用 inline 修饰函数
        - 使用 宏和条件编译 
        - 使用预编译指令（#pragma once）
- RenderDoc中的 [[Hook]] 是怎么实现的？
    - [[Hook]] 的定义
    - [[RenderDoc 的 Hook 是怎么实现的？]]
- std:: move[^6] 的原理?
    - **一个“类型转换函数”，把一个对象**“**显式标记为右值**”，返回右值引用, 以便启用移动语义。
    - 它 **不移动对象本身**，只是告诉编译器：“这个对象你可以偷它的资源”
- [关于参数传递。传很大的结构体时你会怎么做？](关于参数传递。传很大的结构体时你会怎么做？.md)
- 推荐使用return std::move(xxx)吗？为什么? [RVO](RVO.md)
- 描述一下HelloWorld程序开始到显示在屏幕上的全过程？
    1. 用户：执行HelloWorld程序（键盘、鼠标）
    2. 检查程序信息
        1. 找到HelloWorld程序的相关信息，检查类型是否为可执行文件
        2. 通过程序首部信息，确定代码和数据在可执行文件中的位置，并计算出对应的磁盘块结构
    3. 程序启动设置 [[C++程序运行]]
        1. 创建一个新进程，将可执行文件映射到该进程结构中，由该进程执行HelloWorld程序
        2. 为HelloWorld程序设置CPU上下文环境，并跳转到程序开始处。
    4. 程序执行：
        1. 执行HelloWorld程序的第一条指令，发生缺页中断
        2. 分配一页物理内存，并将代码从磁盘中读入内存，继续执行HelloWorld程序
        3. 执行puts函数，在显示器上打印字符串
    5. 在显示器上打印字符串
        1. 操作系统将要打印的字符串发送给对应的进程。
        2. 控制设备的进程告诉设备的窗⼝系统，它要显示该字符串，窗⼝系统确定这是⼀个合法的操作，然后将字符串转换成像素，将像素写⼊设备的存储区
        3. 视频硬件将像素转换成显示器可接收和⼀组控制数据信号
        4. 显示器解释信号，激发液晶屏
- 介绍一下 C++新特性
    - [[C++11]]
    - [[C++14新特性]]
    - [[C++17新特性]]
    - [[C++23新特性]]
- 程序输出题-1
    - 
        ```cpp
        int main() {
            // 此时pint中存储的地址值为0
            int* pint = 0;
            // 将pint向后偏移6个int，因此地址变成24
            pint += 6;
            printf("%d\n", pint);
        }
        //输出24， 6个int 6*4 ，输出指针地址
      ```
- 程序输出题-2：移动sizeof
    - a 是数组名字,**作为指针使用时自动退化为指向首元素的指针**

        ```cpp
        #include <stdio.h>
         int main ()
        {
            // a是数组的名字，指向数组的首地址
            int a[5] = {1,2,3,4,5};
            // &a是指向五个int的数组指针
            // &a + 1会将地址向后移动sizeof(int) * 5，此时p指向第二个int数组的首地址
            int *p = (int*)(&a + 1);  
            // p - 1指向上一个int数组的最后一位
            printf("%d %d" , *(a + 1), *(p - 1));
        }
        //2 ,5
        ```

- CPU常见操作的时钟周期
    - ![[assets/image 1.png]]
- 什么是段错误？哪些情况会引发段错误？
    - 段错误发生在程序试图访问未被允许或不存在的内存区域时。
    - 段错误通常会导致程序崩溃，并且是由操作系统检测到并报告的。
    - 引发段错误的常见原因：
        - nullptr解引用
        - 越界访问数组
        - 使用已经被释放的内存
        - 栈溢出
        - 错误的类型转换，导致指针指向不正确的位置
- 如何判断大端还是小端？
    - 大端：数据的高位存储在低地址，高-低
    - 小端：数据的低位存储在低地址，低-低
    - 0x1234 的低位 34,存储在低地址. 即 0x34, 0x12, 0x00,0x00. (从低到高) ,现代CPU 基本都采用小端,为了兼容, 易扩展, 易于硬件实现

        ```cpp
        bool is_little()
        {
          int i = 0x1234;
          char c = static_cast<char>(i);
        
          return c == 0x34;
        }
        ```

- c++中的常见异常有哪些？
    - bad_typeid：使用typeid()时，传入一个多态类型的指针，且该指针为null
    - bad_cast：从基类对象向派生类的转换
    - bad_alloc：使用new进行动态内存分配时
    - out_of_range：使用vector或者string下标越界时
- c++中函数调用的过程是怎样的？
    - 调用函数前的准备：保存上下文
    - 压入函数的返回地址
    - 压入函数的参数，从右往左：第一个参数，最后一个入栈
    - 创建一个新的栈帧，用于保存局部变量和临时数据
    - 执行函数体
    - 函数返回
    - 栈帧销毁
- a++和++a区别，是左值还是右值？
    1. ++a：左值
        1. 读取a
        2. a自增
        3. 返回a
    2. a++：右值
        1. 使用一个临时变量temp来保存a
        2. a自增
        3. 返回临时变量temp
- 模板类为什么要放在一个头文件里面？
    - 模板实例化是发生在编译阶段的（而不是链接阶段），此时要求在该编译单元内看到模板的完整定义，才能生成实例代码。
    - 如果将声明和实现分离开，那么在编译阶段就无法获得完整定义。
- 有哪些运算符必须重载为成员函数？
    - C++语言标准规定了这些运算符的**左操作数必须是该类的一个对象（即 `this` 指针所指向的对象）**。将它们实现为成员函数是保证这一点的唯一方式。
        - 如果你把某个运算符重载为**成员函数**，那么在使用这个运算符时，左边的那个对象，**必须是这个类的对象**
        - 将它们实现为成员函数是保证这一点的唯一方式。
        - 也就是说**不允许**存在全局（非成员）的重载版本
    - **赋值运算符 `=`** (Assignment operator)
    - **下标运算符 `[]`** (Subscript operator)
    - **函数调用运算符 `()`** (Function call operator)
    - **成员访问运算符 `->`** (Member access operator)

[^1]: 指向 vector 容器内元素的指针
[^2]: 八字节
[^3]: 后缀 `_t` 代指 type
[^4]: 默认开头是 1, 所以可以多利用一位
[^5]: - **读取 (Read)**：先乐观地假设没有冲突，从共享内存中读取当前的状态值（例如，栈顶指针 `current_head`）。
    - **计算 (Compute)**：在本地根据读取到的值，计算出你想要的新状态（例如，创建一个新节点 `new_node`，让它的 `next` 指向 `current_head`）。
    - **比较并交换 (Compare-and-Swap)**：使用原子指令尝试更新共享状态。这个操作会原子地执行以下逻辑：

        > **“如果”** 共享内存中的值**仍然**等于我当初读取的 `current_head`，**“那么”** 就把它更新为我的 `new_node`，并返回成功。 **“否则”**（意味着在我计算期间，被其他线程抢先修改了），就什么都不做，返回失败，并把最新的值告诉我。

    - **重试 (Retry)**：如果上一步失败了，就用刚刚获取到的最新值，从第1步开始**循环重试**，直到成功为止。

[^6]: ```cpp
    void Foo(int);
    void Foo(const int); // 重复声明 
    void Foo(int const); // 重复声明 
    
    void Foo(int&); 
    void Foo(const int&); // 新函数，常量引用 
    
    void Foo(int*);
    void Foo(const int*); // 新函数，用于指向常量的指针
    ```
