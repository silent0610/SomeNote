---
Type:
aliases: 
tags: 
modifiedDate: 2025/06/18, 17:00:46
---

# 虚函数面经

## 虚函数

- C++的虚函数机制是怎样实现的？
    - [[C++虚函数]]
- 虚表有多大[[虚表存储大小]]
- 重载、重写、重定义的区别？
    - 重载 (overlord): 函数名相同，**返回类型可以不同**,[^1] 参数列表不同，根据传入参数数量、类型的不同选择不同版本的函数进行调用。（C++中的函数名字会将参数加在后面[^2]，从而判断具体执行哪个函数）
    - 重写 (Override): 子类覆盖基类的虚函数，要求两个函数同名、参数相同，且父类函数必须有virtual关键字
    - 重定义 (redefining): 子类对父类中的非虚函数进行重新定义实现。要求两个函数同名、参数相同。
- 子类重写了虚函数会对虚函数表有什么影响？
    - 即将虚表对应项指针替换为子类重写的函数的指针
- final 和 override 关键字 
    - [[C++11]]
    - final:
        - 修饰类, 表明当前类是继承树的最后一环, 阻止被继承
        - 修饰函数: 表明这个函数不能被重写
    - override
        - 修饰成员虚函数, 表明当前虚函数是对基类虚函数的重写
- 继承关系中，析构函数调用顺序是什么？
    - 派生类析构函数
    - 按声明顺序 (出现在代码里的顺序), 析构成员对象
    - 相同方式, 逐个析构基类
- 为什么析构函数要声明为虚函数?如果基类不使用虚的析构函数，会发生什么？
    - [[虚析构函数]]
- 构造函数可以声明为虚函数吗？
    - 不能:
    - 从设计角度来说：调用虚函数的时候，只需要知道函数接口即可，不需要知道具体的对象类型。然而在创建对象的时候，我们需要知道对象的完整类型，因此构造函数不应该被定义为虚函数。
    - 从编译器角度来说: 虚表是在构造函数执行完成之后才初始化, 建立的。如果构造函数是虚函数，那么我们在对象构造的时候是没有虚函数表指针的，无法找到对应的构造函数进行调用。见[[构造函数可以是虚函数吗]]
- 创建10个实例有几个虚函数表？
    - 1 个, 一个有虚函数的类有一个虚表
- 哪些函数不能是虚函数？
    - 内联函数、静态函数、构造函数、友元函数、lamda函数
    - 其中友元函数、lambda函数、普通函数因为**没有类继承特性**，**不属于类的一部分**，因此都不能是虚函数。
    1. 内联函数（inline）：**内联函数是在编译期展开的，它没有函数符号**（在编译后的代码中没有单独的符号或者地址与它们相关联。在使用内联函数的时候，它的代码会直接插入到对应的调用位置，而不是通过函数符号或者地址进行调用），因此无法将其放入虚函数表中。因此，内联函数不能被声明为虚函数。（内联是为了减少函数调用，和虚函数的实现目的相背）
    2. 静态函数：静态函数是与类相关联的函数，它**不依赖于对象的调用**。由于**虚函数是通过对象调用的**，因此静态函数不能被声明为虚函数。**静态函数没有this指针**，也找不到虚函数表指针。
    3. 构造函数：在对象构造的时候才会生成虚函数表指针，如果构造函数是虚函数，那么此时我们找不到构造函数的。
    4. 友元函数：友元函数不是类的成员函数，它不能被继承。因此，没有继承特性的函数不能是虚函数。
    5. lambda 函数：它是一种匿名函数，它没有类层次结构，无法直接作为虚函数使用。
    6. 普通函数：即不属于类的函数，没有继承特性，因此不能是虚函数
- 怎么理解 [[C++虚函数]]？什么是纯虚函数？虚函数与纯虚函数的区别？
    - 虚函数：派生类可以对虚函数进行重写，允许通过基类指针调用派生类的虚函数。虚函数通过在函数声明前加上virtual进行标识。
    - 纯虚函数：必须由派生类进行实现，自己本身没有函数实现，只有声明。纯虚函数通过在函数声明后加上 `=0` 来标识。
        - 基类中包含纯虚函数的类被称为抽象类，它不能被实例化。派生类必须实现基类中的纯虚函数，否则派生类也会成为抽象类。
- 什么是多态？c++的多态是如何实现的？
    - [[C++多态]]
- 虚函数的实现机制是什么？
    - [[C++虚函数#实现]]
- 虚函数调用是在编译时确定的还是运行时确定的？如何确定调用哪个函数？
    - 静态类型：这是编译时已知的类型，即编译器在编译时推断出的变量或表达式的类型。静态类型是基于代码中声明的类型。
    - 动态类型：这是运行时的实际类型，即对象在运行时的实际类型。动态类型是基于对象的实际实例。
    - 如果一个表达式不是引用或者指针，那么它的动态类型和静态类型是一致的。
    - 只有通过指针或者引用的方式调用虚函数的时候，才会在运行时确定具体调用的虚函数；其余调用的虚函数在编译期就可以确定。不过对于一些能够在编译期推断出来的虚函数调用，编译器会进行一些优化。
- 虚函数是存在类中还是类对象中（即是否共享虚表）？
    - 存在类中，不同的类对象(同属一个类)共享一张虚函数表（为了节省内存空间）
- 在（基类的）构造函数和析构函数中调用虚函数会发生什么？
    - 这种做法在语法上面没有问题，但是从调用效果上来看，往往不能达到需要的目的，即无法实现多态。
    - 即**只能调用自己的函数**
    - 原因
        - 在调用派生类构造函数的时候
            - 首先会先进行基类成员的构造，然后再进行派生类成员的构造。
            - 在基类构造期间，派生类的成员还没有进行初始化，此时如果调用的是派生类的虚函数，我们就使用了未进行初始化的数据。
            - 所以**只会调用自己的虚函数**
        - 调用析构函数的时候
            - 首先会先对派生类对象进行析构，然后再对基类对象进行析构。
            - 在进入基类对象的析构时，此时派生类对象的成员已经销毁了，此时是无法调用派生类重写的虚函数的。
            - 所以**只会调用自己的虚函数**
- C语言可以实现虚函数机制吗，如何实现？
    - 人工构造继承关系。
    - 创建虚函数表，填充虚函数表，设置虚函数表指针指向虚函数表。
    - 当虚函数重写的时候，修改函数指针。
- 通过指针或引用调用虚函数时一定要查虚函数表吗？
    - 一般来说是这样的
    - 但是现代**编译器会进行很多优化**，对于一些可以推断出动态类型的调用，会在编译期间进行绑定。例如使用**final**对虚函数或者派生类进行**修饰**，此时派生类对象的引用或者指针所调用的虚函数，一定是该派生类自身的那个，因此不需要在等到运行时进行绑定。
        - 基类有一个 final 的虚函数 `func`
        - 子类没有这个虚函数
        - 使用基类指针时只会调用基类的 `func`, 因为子类中不存在这个函数, final
- 类B，类C都继承类A，并且各自重写了A的虚函数，请问运行时有几个虚函数表
    - 3个，每个类一个。
- 如果类 D 继承了 B 和 C 呢? D 对象的内存有几个虚表指针?
    - 两个, 继承几个有几个虚表指针, 自身的新虚函数会合并在第一个虚表里
    - 自身的新的字段也跟在开始的内存中
- 在多继承情况下，虚函数表和虚函数表指针的情况如何？
    - ![[assets/image.png]]
- 加入虚函数后是否会影响对象大小，影响的话增加了多少大小？
    - 即 `虚表指针数量` x `虚表指针的大小(64位系统为8B)`
- [[类的虚表指针什么时候建立]]
- 虚函数表指针一般存在对象的什么位置？MSVC和GCC会放在头部，放在头部有什么好处？有什么坏处？
    - 放在对象内存头部
        - 多继承的情况下有不同
    - 好处：
        1. 位置统一：将虚函数表指针放在对象的头部，可以确保在任何派生类中，虚函数表指针的位置都是一致的。这样可以简化编译器的实现，使得派生类的对象可以方便地访问和调用基类的虚函数。
        2. 快速访问：将虚函数表指针放在对象的头部，可以使得**通过对象指针直接访问虚函数表指针**，而不需要进行额外的偏移计算。这样可以提高虚函数的调用效率。
    - 坏处：
        1. **内存占用**：虚表指针存在对象中会占用一定内存. 将虚函数表指针放在对象的头部会占用对象的一部分内存空间。对于大量对象的情况下，这可能会导致额外的内存开销。
        2. 对象布局：将虚函数表指针放在对象的头部可能会影响对象的布局，特别是当对象包含其他成员变量时。这可能会导致**对象的内存布局不连续**，增加内存访问的成本。
- 编译器是如何处理虚函数表的？
    1. 拷贝基类的虚函数表，如果是多继承，就拷贝每个具有虚函数的基类虚函数表
    2. 检查派生类中是否重写了基类的虚函数，如果有，就替换成已经重写了的虚函数地址
    3. 检查派生类中是否有新的虚函数，如果有，就追加到自身的虚函数表中[^3]。
- [[C++多继承对象内存布局]]
- 析构函数的特点和作用？
    - 作用：在销毁对象的时候进行调用，负责执行一些特殊处理。
    - 特点：
        1. 与构造函数同名，前面加~
        2. 没有参数，没有返回值，不能进行重载。
        3. 当类内没有析构函数的时候，编译器会**生成默认的析构函数**。
- 构造函数可以是虚函数吗？为什么？[构造函数可以是虚函数吗](构造函数可以是虚函数吗.md)
- 析构函数可以是虚函数吗？为什么一定要是虚函数？[虚析构函数](虚析构函数.md)
- [虚表指针存在什么地方?为什么](C++虚表指针.md)
- [虚表一般放在哪里？为什么？](C++虚表.md)
- 将一个类实例化多次，会导致虚表占用的内存增加吗？[效率](C++虚表.md#为什么存在这里)
- [现在的编译器里怎么实现虚表，如果是多继承呢？](虚表的实现.md)
- 如果给你一个内存紧缺的系统，目前的实现里存在很深的继承，每次继承都会 override 掉少数几个方法。此时你会如何实现虚表？[极端情况下的虚表实现](极端情况下的虚表实现.md)
- [虚继承](虚继承.md)

[^1]: 不根据返回类型判断是否重载
[^2]: 不同编译器有不同的重命名方法
[^3]: 第一个虚表指针中
