---
Type:
aliases: 
tags: 
modifiedDate: 2025/06/28, 11:46:28
---

# 纹理贴图面经

## 介绍虚拟纹理 ？

[[虚拟纹理]]

## 知道哪些纹理贴图的压缩算法？纹理压缩的目的和方法？

[[纹理压缩]]

## 贴图的mipmap的每一级是怎么生成的？

[[MipMap]]
- 如果纹理参数和最终的着色颜色之间**具有线性关系**，则可以直接使用每 $2 \times 2$ 纹素的平均值来作为下一级mipmap的纹素值。
- 如果纹理参数和最终的着色颜色之间具有非线性关系，则需要使用特殊的滤波方法，常见的非线性参数就是法线，因此对于法线贴图，需要特殊处理，一般会将着色方程的输入参数作为一个整体来进行过滤，而不适单独对法线贴图进行过滤。Toksvig使用了一种基于法线长度来修改NDF粗糙度参数的方法，并使用修正后的粗糙度参数来重新计算BRDF，从而对过滤后法线的扩散效果进行近似。
- 对于在非线性颜色空间中编码的纹理（例如大多数的彩色纹理），会首先将其转到到线性空间中，完成mipmap的生成和过滤之后，然后将最终的结果转换回sRGB颜色空间中并进行存储。

## Mipmap是什么？Mipmap的原理、作用？为了解决什么问题？为什么要把贴图mipmap？

[[MipMap]]
[[MipMap#根本原因]] 

## 摩尔纹怎么产生的？

根据[[奈奎斯特定理|奈奎斯特极限]]
远处的信号的采样率过低，即屏幕上的一个像素，对应了纹理贴图中的多个纹素。

## 如果不给shader采样层级，怎么知道用哪一层Mipmap？如何确定使用哪一层Mipmap？

(简单来说：比较当前pixel周边 (比如上下左右) 像素们的 uv变化量，然后取其中最大变化量，再取对数。)
如何确定使用哪一层mipmap，核心思路是使得屏幕上的一个像素，大致对应1-2个左右的纹素。由于屏幕像素在纹理空间的投影一般都是一个不规则四边形，一般有两种常用方法：

1. 利用像素单元格投影后所形成的四边形，取其较长的那个边来对像素的覆盖范围进行近似。
    - 让这个边为纹素长度接近 1 的 mip 等级
2. 使用四个梯度（u,v分别对x,y的梯度）中的绝对值最大的那个，或者某种组合来作为度量。例如其中一种方法如下：

$$
D=\log _{2} L \quad L=\max \left(\sqrt{\left(\frac{d u}{d x}\right)^{2}+\left(\frac{d v}{d x}\right)^{2}}, \sqrt{\left(\frac{d u}{d y}\right)^{2}+\left(\frac{d v}{d y}\right)^{2}}\right)
$$

## 法线贴图的相关概念？讲一下法线贴图原理？法线映射怎么做？

[[法线贴图]]

法线贴图基于了这样的一个思想：在纹理中编码细观尺度细节。
法线贴图的具体做法是: 
- 不直接使用纹理贴图来改变光照方程中的颜色参数, 而是使用纹理贴图来对表面的法线数据进行偏移, 从而模拟一个具有细节的表面

## 为什么是偏蓝的？法线贴图为什么是蓝色的？

法线贴图呈现蓝色，是因为这张图上绝大部分的区域都代表着“基本平坦”的表面，其法线向量笔直朝外（Z轴分量最大），这个“朝外”的方向恰好被编码为最强的蓝色通道值，从而让整张图呈现出标志性的蓝色调。
- 法线贴图中存储的是模型表面切线空间内的法线方向, 经过 [[TBN]] 矩阵转换后得到世界空间或 viewspace 法线, 然后作为着色计算输入被使用

## 法线空间到世界坐标的变换计算等？

[[TBN]]
切线向量和副切线向量代表了物体空间坐标系中法线贴图本身的坐标轴，这三个向量，世界空间法向量 $\mathbf{n}$，世界空间切线向量 $\mathbf{t}$，和副切线向量 $\mathbf{b}$，构成一个基底矩阵：

> **注: 这里向量被视为行向量。** 为 v x M, 行向量右乘矩阵. **解释见[[行主序与列主序]]**

$$
\left(\begin{array}{cccc}t_{x} & t_{y} & t_{z} & 0 \\ b_{x} & b_{y} & b_{z} & 0 \\ n_{x} & n_{y} & n_{z} & 0 \\ 0 & 0 & 0 & 1\end{array}\right)
$$

TBN是基底矩阵, 用于把法线从切线空间转换到世界空间

## 法线贴图是怎么存储的？为什么？优点缺点？存储法线贴图需要注意什么？

1. 直接存储法线的x,y,z数据，[−1,1]转换到[0,1]
2. 只存储x,y数据，利用归一化特性重建zzz。
3. 使用球坐标，存储两个角度参数，重建球面上的归一化法线。
4. 八面体映射，将球面投影到一个八面体上，压缩效果好，编解码速度快。
5. 球极投影（Stereographic Projection）
6. 使用球面贴图
7. Per-pixel View Space：view space中的法线z分量始终为正，可以节省一半精度。

## 切线空间是什么？了解切线空间吗？

[[切线空间]]
为了将光线转换到表面着色点的局部空间（反之亦可），并使用法线贴图来修改顶点法线，我们需要存储一个逐顶点的切线坐标系，即切线空间，也被叫做切线空间基底，在这个空间中，顶点法线指向z轴正方向。除了顶点法线之外，我们还存储了所谓的切线向量（tangent vector）和副切线向量（bitangent vector）。其中副切线有时也被错误地称为副法线（binormal）。
- **法线 (Normal - N):** 垂直于表面的方向，通常是低模本身的法线方向，作为这个空间的 Z 轴。
- **切线 (Tangent - T):** 沿着表面 U 纹理坐标增加的方向，作为 X 轴。
- **副切线 (Bitangent - B):** 同时垂直于法线和切线的方向，作为 Y 轴。

## 法线贴图时为什么要使用切线空间而不是模型空间？

- 首先, 法线贴图是可以存储在模型空间中的. 只需要经过model变换, 就可以转换到世界空间, 见[[法线变换]]
- 至于为什么通常使用切线空间, 主要有三个原因
    - 更好的复用性
        - 切线空间的法线是可以复用的, 是与模型无关的, 你可以把它应用到城墙, 地面, 甚至铠甲上
    - 与顶点动画兼容.模型空间的法线是不变的. 如果把法线存储在模型空间, 由于顶点混合, 一个在手臂伸直时指向前方的法线，在手臂弯曲后其绝对方向并不会改变。
    - 更好的压缩性. 按照约定, 切线空间的法线的z始终大于0, 带来更好的可压缩性.

## 法线贴图是在顶点着色器还是片段着色器中计算？

- 法线贴图在像素着色器中被采样, 并重建出对应法线.
- 但是TBN矩阵通常在顶点着色器中计算, 然后经过光栅化插值到像素着色器中进行计算
    - 这么做通常有几个问题
        - 插值后导致向量不再正交, 不再归一化, TBN 矩阵不准确
        - 占用插值器

## 伽马矫正是什么？为什么？

[[伽马校正]]

## HDR 是什么? 为什么?

-  [[HDR]] 的全称是高动态范围, 与之相对应的是 LDR. HDR技术能够让一幅画面同时呈现出更亮的亮部、更暗的暗部以及更丰富的色彩细节，从而使画面更接近人眼在真实世界中所见的景象。
- **传统SDR技术的局限性已经无法满足我们对视觉真实感的追求**

简单对比
- HDR
    - 范围更大, 不易丢失高亮和深黑信息
    - 峰值亮度更大
    - 色域更广, DCI-P3
    - 色深能达到 10bit, 色彩更平滑
- SDR
    - 范围小, 亮部和暗部难以区分
    - 色域窄, 通常使用 sRGB
    - 8bit 色深, 可能出现层级感

## 纹理映射是什么？

- 纹理贴图是一种用于描述表面材质和修饰加工的有效技术
- 使用纹理坐标, 映射到纹理空间内, 读取对应的纹素值, 获得对应的顶点属性
- 常用的纹理映射包括
    - 材质映射 / 纹理映射
        - base color (albeo
        - AO
        - metallic 和 roughness
    - Alpha映射 Alpha映射利用纹理的**Alpha通道**来控制模型表面每个像素的不透明度。
    - 凹凸映射 (Bump Mapping) 与 法线映射 (Normal Mapping)
        - 凹凸映射， 使用一张**灰度图（高度图）**来存储表面的凹凸信息。在渲染时，它并**不直接改变**模型的法线，而是通过算法扰动（Perturb）原始法线，使其在光照计算时产生凹凸的假象。
        - 法线贴图
    - 视差映射
        - 不仅使用法线贴图来影响光照，还使用一张**高度图**，并根据观察者的视角来**移动（偏移）**纹理的采样坐标。

## 纹理缩小方法、扩大方法？

- 纹理放大是将一个较小尺寸的纹理，变成一个较大尺寸的纹理，常见方法有：
    - 邻近过滤（nearest neighbor）：box滤波器。
    - 双线性插值（bilinear interpolation）：找到四个相邻的纹素，并在二维上进行线性插值从而获得混合后的像素值。
    - 三次卷积插值（cubic convolution）：使用了4 × 4或者5 × 5范围大小纹素的加权和。
- 纹理缩小是指将一个较大尺寸的纹理，变成一个较小尺寸的纹理，即将多个纹素组合起来，常见方法有：
    - 用于缩小的邻近过滤、双线性插值。
    - mipmap
        - 各向异性过滤
    - SAT：面积积分表，某个位置上的纹素会和(0,0)处纹素（原点）构成一个矩形，计算并存储区域中所有纹素值的总和。在纹理化的过程中，屏幕上的像素在纹理上的投影区域是一个矩形；然后会通过SAT来确定这个矩形区域的平均颜色，并将其作为该像素的纹理颜色。
        - 见 RTR4 6.2.2
- 说一下双线性插值和三线性插值？
    - 双线性插值：使用纹理坐标(u,v)，分别在x,y方向上进行线性插值。
    - 三线性插值：
        - 使用纹理坐标(u,v)和细节层级d，对d两侧的miamap分别进行采样，
        - 即使用坐标(u, v)来从这两个mipmap中分别进行双线性插值，获得两个纹理值。
        - 最后按照参数d再对这两个纹理值进行一次线性插值。

## mipmap的原理？作用？如何确定使用哪一层？

- mipmap 通过对原始纹理进行一系列过滤, 不断生成原始尺寸 1/4 的纹理, 直到最终生成的纹理维度为 1.
- 在采样纹理的时候, 根据附近像素的梯度信息计算所需采样的 mip 等级. 随后进行三线性插值
- mipmap 可以提高缓存命中率
    - 原来对于相邻的两个像素, 可能要去找相距 100 的纹素. 使用 mipmap 后, 他们的 mip 等级类似, 只用找相同的 mip 等级中比较靠近的纹素, 极大的提高了缓存命中率
- 为什么要存在 mipmap? 由于[[奈奎斯特定理|奈奎斯特极限]], 采样频率必须在原始信号两倍以上才能完美重建信号. 我们通常无法提高采样频率 (提高分辨率), 只能降低原始信号的频率. mipmap 通过对纹理进行降采样, 过滤高频信号, 从而满足条件. 尽量满足 1:1的理想情况.

[[#如果不给shader采样层级，怎么知道用哪一层Mipmap？如何确定使用哪一层Mipmap？]]
