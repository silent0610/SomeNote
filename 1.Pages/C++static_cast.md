---
Type: 
aliases:
  - static_cast
tags: 
modifiedDate: 2025/06/17, 15:58:33
---

# static_cast

翻译为: **静态类型转换** 或 **编译期类型转换**。

- **用途**：
    - 执行编译期类型转换，例如 `void*` 到其他类型的指针（需要程序员确保安全）。
    - 执行类层次结构中**向上转型（upcasting）**，即从派生类指针/引用转换为基类指针/引用。这是安全的。
    - 执行类层次结构中**向下转型（downcasting）**，即从基类指针/引用转换为派生类指针/引用。**不进行运行时检查**，如果转换不安全（即基类指针实际没有指向派生类对象），会导致未定义行为。
    - 进行基本数据类型之间的转换（如 `int` 到 `float`，或 `enum` 到 `int`）。
    - 将 `enum class` 类型转换为其底层整数类型。
- **安全性**：
    - **编译时检查**：`static_cast` 只能用于编译器知道如何转换的类型。
    - **无运行时检查**：它**不执行任何运行时类型检查**。如果转换不安全（特别是向下转型），编译器不会报错，但程序会在运行时出现问题。因此，使用 `static_cast` 进行向下转型需要程序员自己保证转换的正确性。
- **语法**： `static_cast<目标类型>(表达式)`

## 怎么进行向上转型?

`static_cast` 是一个**编译时**的类型转换。当它被用于向上转型时，编译器会根据类的继承信息来计算指针地址的调整。

> 返回一个目标类型的指针,指针位置视类型决定

### a) 单继承的情况

```cpp
class Base { /*...*/ };
class Derived : public Base { /*...*/ };

Derived* d_ptr = new Derived();
Base* b_ptr = static_cast<Base*>(d_ptr);
```

在这种最简单的情况下，`Base` 子对象通常就位于 `Derived` 对象的内存布局的**最开始**。因此，`d_ptr` 和 `b_ptr` 的**地址值是完全相同的**。编译器在这里做的仅仅是**类型的重新解释**，几乎没有任何运行时开销。

==即返回,Base 指针,指针位置和原位置相同==

### B ) 多重继承的情况

```cpp
class Base1 { /*...*/ };
class Base2 { /*...*/ };
class Derived : public Base1, public Base2 { /*...*/ };

Derived* d_ptr = new Derived();
Base1* b1_ptr = static_cast<Base1*>(d_ptr); // (1)
Base2* b2_ptr = static_cast<Base2*>(d_ptr); // (2)
```

- **转换(1)**：与单继承类似，`Base1` 作为第一个基类，其子对象位于 `Derived` 对象的开头，所以 `b1_ptr` 的地址值和 `d_ptr` 相同。
- **转换(2)**：`Base2` 子对象位于 `Base1` 子对象之后，有一个**固定的、在编译期就已知的偏移量（offset）**。编译器在执行这个 `static_cast` 时，生成的汇编代码就是简单地**将 `d_ptr` 的地址值加上这个固定的偏移量**。这是一个极快的算术操作。
