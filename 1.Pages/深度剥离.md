---
Type:
  - Page
aliases:
  - depth peeling
tags: 
modifiedDate: 2025/06/19, 11:12:42
---

# 深度剥离

是一种 [OIT](OIT.md)

## 原理

深度剥离的核心思路是使用两个z-buffer和多个pass:
- 通过多遍渲染来“剥离”场景中的透明层。每一遍渲染都提取一个最靠前的透明层。

## 原理

- **准备工作**：渲染场景中所有**不透明**的物体，并将颜色和深度信息保存到主缓冲区。
- **第1遍（Pass 1）：剥离最外层**
    - 渲染所有**透明**物体。
        - 使用 zbuffer2 作为 zbuffer
    - 使用**标准深度测试**（`GL_LESS`），将最靠近摄像机的片元（fragment）的颜色绘制到“第1层颜色纹理”中，将 zbuffer2 复制到 zbuffer1 中
    - **结果**：我们得到了场景中最靠近摄像机的那个透明表面。
- **第2遍（Pass 2）：剥离第二层**
    - **再次**渲染所有透明物体。
        - 仍然使用 zbuffer2
    - **关键步骤**：在本次渲染的片元着色器（Fragment Shader）中，将当前片元的深度与上一步保存的**“zbuffer1”**中的值进行比较。
    - 我们只接受并绘制那些**深度值更大**（即距离摄像机更远）的片元。
    - 将这些符合条件的“第二层”片元的颜色绘制到“第2层颜色纹理”, 或者直接使用 **under**混合
        - 将 zbuffer2 复制到 zbuffer1 中, 即更深的片元
    - **结果**：我们得到了场景中第二靠近摄像机的透明表面。
- **后续通道（Pass 3, 4, ...）**
    - 重复上述过程。第 N 遍渲染会使用第 N-1 遍的深度信息，来剥离出第 N 层的颜色和深度。这个过程可以重复多次，直到剥离出足够多的层数或没有片元再通过深度测试。
- **最终合成（Final Composition）**
    - 这个步骤不是必须的, 可以在每个 pass 绘制时直接按照 alpha , 使用 **under** 运算符进行混合
    - 现在我们有了一系列从前到后的透明层（Layer 1, Layer 2, Layer 3...）。
    - 将这些层**从后往前**（Back-to-Front）依次混合到最开始渲染的不透明场景上。例如，将 `Layer 3` 混合到 `Layer 2` 上，再将结果混合到 `Layer 1` 上，最后将总结果混合到主屏幕上。
    - 这样就得到了最终的、渲染正确的图像。

**流程**:
1. **初始化**: 准备一个最终的**“累积颜色缓冲区”（Accumulated Color Buffer）**，其初始内容是不透明场景的渲染结果。
2. **剥离并混合**:
    - **Pass 1**: 剥离出最前面的一层（Layer 1），使用标准的 "over" 混合模式，将其颜色混合到“累积颜色缓冲区”中。
    - **Pass 2**: 剥离出第二层（Layer 2）。现在，我们需要将 Layer 2 的颜色“垫”在累积颜色缓冲区的**下面**。这就是您提到的 **"under"** 运算符所做的事情。
    - **重复**: 第 N 遍剥离出 Layer N，并将其“垫”在累积缓冲区的颜色后面。

## 优缺点

- **优点**：可以生成非常精确的透明度，处理穿插几何体。
- **缺点**：
    - **性能开销巨大**：需要多遍渲染（N 次 Draw Call），N 通常很高。对于复杂场景，帧率无法接受。
    - 内存占用也相对较高（需要多个深度缓冲）。
