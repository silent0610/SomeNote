---
Type:
  - Page
aliases: 
tags: 
modifiedDate: 星期二, 六月 3日 2025, 10:25:58 晚上
---
析构函数之所以常常必须是虚函数，是为了**避免内存泄漏**和**确保多态性下的资源正确释放**，尤其是在通过**基类指针删除派生类对象**时。

- 析构函数**可以**是虚函数。
- **当且仅当一个类打算被用作基类，并且可能会通过基类指针（或智能指针）来删除派生类的对象时，它的析构函数**必须**声明为虚函数。**
- 如果一个类没有任何虚函数，并且不打算被继承或不涉及通过基类指针删除派生对象，那么析构函数就不需要是虚函数，甚至不应该是虚函数（虚函数会增加对象大小和虚函数调用的开销）。
- 然而，**一般最佳实践**是：**只要类中存在虚函数，其析构函数也应声明为虚函数**，以避免潜在的内存泄漏问题。

## 原理

### 非虚函数

- 当 `Base* b_ptr = new Derived();` 时，虽然 `b_ptr` 是 `Base` 类型，但它实际指向的是一个 `Derived` 对象。
- 当执行 `delete b_ptr;` 时，C++ 编译器会尝试根据**指针的静态类型**（即 `Base*`）来决定调用哪个析构函数。
- 如果 `Base` 的析构函数**不是虚函数**，那么就只会调用 `Base` 的析构函数。**不会发生运行时多态查找**。
- 结果是，`Derived` 类中分配的资源（如 `data = new int[10]`）将永远不会通过 `Derived` 的析构函数得到释放，从而导致**内存泄漏 (Memory Leak)**。

### 虚函数

- `delete b_ptr_virt;` 会触发运行时多态机制。
- 编译器通过 `b_ptr_virt` 指向的 `Derived_Virt` 对象的虚表指针（vptr），找到 `Derived_Virt` 类的虚表。
- 在虚表中，找到 `Derived_Virt` 的析构函数地址并执行。
- 然后，`Derived_Virt` 的析构函数会自动调用其基类 `Base_Virt` 的析构函数。[^1]
- 这样就保证了从最派生类到基类的完整析构链被正确执行。

[^1]: 由编译器实现
