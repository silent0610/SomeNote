---
Type:
  - 算法题
aliases: 
Status: 
tags: 
难度:
  - 中等
modifiedDate: 星期一, 五月 19日 2025, 7:44:50 晚上
---
## 题目
给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例 1:**

**输入:** nums = [1,2,3,4,5,6,7], k = 3  
**输出:** `[5,6,7,1,2,3,4]`  
**解释:**  
向右轮转 1 步: `[7,1,2,3,4,5,6]`  
向右轮转 2 步: `[6,7,1,2,3,4,5]`  
向右轮转 3 步: `[5,6,7,1,2,3,4]`

**示例 2:**

**输入：**nums = [-1,-100,3,99], k = 2  
**输出：**[3,99,-1,-100]  
**解释:**  
向右轮转 1 步: [99,-1,-100,3]  
向右轮转 2 步: [3,99,-1,-100]

**提示：**

- `1 <= nums.length <= 105`
- `-231 <= nums[i] <= 231 - 1`
- `0 <= k <= 105`

## 解答
1. 创建另一个数组, 但是空间开销为 $O(n)$
2. 环转替换
	1. 对于第 0 个元素, 用 temp 保存被替换的第 (0+k) mod (n) 个元素. 然后从第 (0+k) mod (n) 元素再次加 k, 即 ((0+k) mod (n) +k) mod (n), 如此循环, 最后会回到原点, 即第 0 个元素. 
	2. 但可能会有元素没有被遍历到. 所以需要多次遍历. 
	3. 下一次循环从哪里开始呢? 需要循环几次呢?
		1. 对于第一个问题, 如果需要循环多次
			1. 从下一个开始遍历即可. 为什么呢? 想象一下各种情况. 假如第 1 个元素没有被访问到. 那说明 (第 0 个和其它被访问的点构成了循环, 不会超过这个循环) 那自然需要从第 1 个元素, 也就是下一个开始遍历. 
			2. 假如第一个被遍历到了呢? 这种情况可能吗? 显然不可能, 如果第 1 个元素被遍历到了, 说明 x 步后会移到第 1 个元素的位置, 那么再过 x 步, 第 2 个元素也会被访问. 递推, 前 k 个元素都会被访问. 所以==**不存在第 1 个元素被访问到了, 但是还需要多次循环的情况**==. 如果初始点的下一个被访问过了, 只可能是之前或本次循环. 所以综上, 从下一个元素开始访问即可
			3. 此外, 是否存在一种可能, 第 0 个和第 k-1 个元素之间有其它元素被访问到呢. 
				1. 这种可能性是存在的. 但无论如何, 这些被访问到的元素构成了一个个闭环, 不同闭环之间是不会相互访问到的. 
				2. 所以如果需要第二次访问, 他所访问的到元素一定是和第 一次访问不一样的
				3. 同样的, ***后面循环访问到的元素都和前面的不同***. 
				4. 结合后面推理的每次循环遍历到 $b=\frac{a*n}{k}$ 个元素, 即可得出结论最多需要 $gcd(n,k)$ 次循环即可访问完 n 个元素. 
			4. 是否可能多次访问到同一个元素呢? 同样不可能, 那说明前一个元素也被访问了多次, 递推回去就是初始点被访问了多次, 而这时不可能的. 
			5. 多次循环的情况下, 结合 **初始点的下一个点一定在另一个闭环**, **不同闭环中的点不同**和 只需 $gcd(n, k)$ 次即可访问 n 个元素, 和只有 $gcd(n, k)$ 个闭环, 以及***闭环是顺序的***(123412345 显然 k=4, 那么 第二个1 既属于闭环 1, 也属于闭环 5, 矛盾), 所以在 $gcd(n, k)$ 次循环时, 即可访问 n 个不同元素, 不可能存在第 $gcd(n, k)+1$ 次循环时, 仍有未访问的元素.
		2. 对第二个问题
			1. 由于最终回到了原点, 所以一定经过了整数圈. 假设圈数为 a. 所以一共经过了 $a*n$ 的距离. 
			2. 又已知每次步长为 k. 假设这么多圈一共遍历到 b 个元素. 
			3. 则有 $b*k=a*n=Dist$, 即经过的距离的两种计算形式.
			4. 所以可知 $b=\frac{a*n}{k}$ 
			5. 又因为当第一次回到出发点就停止. 所以 Dist 尽量小, 也即 a 尽量小. 
			6. 又因为 Dist 一定是 n 和 k 的倍数, 所以 Dist 是 n 和 k 的最小公倍数. 
				1. 这么理解, 如果 每次前进 k 步. 当前进了 n 步时, $Dist = n*k$, 此时已经返回到初始点, 即可结束. 所以一定是最小公倍数
			7. 所以 $a*n = lcm(n,k)$ 
			    >  lcm 即最小公倍数
			8. 所以 $b=lcm(n,k)/k$
			9. 那么一共需要遍历  
			   $$\frac{n}{lcm(n,k)} = \frac{n*k}{lcm(n,k)}=gcd(n,k)$$  
			    > gcd (n, k) 指最大公约数
		3. 如果第二个问题, 如果难以理解, 也可以直接 用 count 变量存储当前访问了的元素数量. 当 count=n 时, 即可结束. 
3. ~~我简直是天才~~

```cpp
class Solution {
public:
    void rotate(int nums[], int n, int k) {
        //O(n) in time, O(1) in space.                  
                                                        
        //special case: when nothing needs be done.     
        if(!nums || n == 0 || k == 0 || n == k) return; 
                                                        
        //common case:                                  
        //step1: reverse entire array.                  
        k %= n;//skip unnecessary move steps.           
        int p = 0;                                      
        int q = n - 1;                                  
        reverse(nums + p, nums + q + 1);                
        //step2: reverse first k elements.              
        q = k-1;                                        
        reverse(nums + p, nums + q + 1);                
        //step3: reverse last (n-k) lements.            
        p = k;                                          
        q = n - 1;                                      
        reverse(nums + p, nums + q + 1);                
        return;                                                                                                     
    }
};
```