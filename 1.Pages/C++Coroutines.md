---
Type: 
aliases:
  - C++协程
tags: 
modifiedDate: 2025/06/19, 09:24:13
---

# C++Coroutines

## 定义

可以把协程理解成一个**可以暂停和恢复的函数**。普通函数一旦开始执行，就必须运行到结束才能返回。而协程可以在执行过程中的任何位置**主动**暂停自己，交出控制权，然后在未来的某个时刻从它暂停的地方继续执行，并且它暂停时的所有状态（比如局部变量）都会被完整保留。

## 例子

### 代码

**回调形式**

```cpp
// 启动操作
getUserInfo(123, [](UserInfo user) {
    // 第一层回调：成功获取到用户信息
    std::cout << "获取到用户: " << user.name << std::endl;

    // 用用户信息去获取好友列表
    getFriendList(user, [](FriendList friends) {
        // 第二层回调：成功获取到好友列表
        std::cout << "获取到好友 " << friends.count << " 个" << std::endl;

        // 如果还有下一步，就要继续嵌套...
        saveToDatabase(friends, [](bool success){
            // 第三层回调...
        });
    });
});
// 代码不断向右延伸，逻辑割裂
```

**协程方式**

```cpp
// 协程函数返回一个 future/task
Task fetch_user_and_friends(int userId) {
    // 看，代码是平铺直叙的！
    try {
        UserInfo user = co_await getUserInfo(userId);
        std::cout << "获取到用户: " << user.name << std::endl;

        FriendList friends = co_await getFriendList(user);
        std::cout << "获取到好友 " << friends.count << " 个" << std::endl;

        bool success = co_await saveToDatabase(friends);

    } catch (const std::exception& e) {
        // 异常处理也变得非常简单
        std::cerr << "出错了: " << e.what() << std::endl;
    }
}
// 逻辑一目了然，就像在写普通函数
```

### 比喻

#### 方式一：单线程同步执行

你先去厨房把水壶放到炉子上，然后就**一直站在那里，盯着水壶**，直到水烧开为止。在这个过程中，你什么也做不了。水烧开后，你再去书房看书。

- **特点**：简单直接，但效率低下。在“等水开”这个耗时的I/O操作中，你（CPU）被完全**阻塞（Block）**了，造成了巨大的浪费。

#### 方式二：多线程执行

你雇一个保姆（一个新线程）。你（主线程）去烧水，把水壶放到炉子上后，就告诉保姆（子线程）：“你在这里盯着水，水开了叫我。” 然后你就可以立刻回到书房去看书了。保姆会在水烧开时通知你。

- **特点**：效率高，你没有被阻塞。但问题是，雇保姆（创建新线程）需要**成本**（内存、系统资源），而且你和保姆之间的沟通协调（线程同步）也需要小心处理，不然容易出错。如果任务很多，比如要同时做饭、扫地、洗衣服，你需要雇很多个保姆，管理起来会非常混乱和昂贵。

#### 方式三：协程执行

还是只有你一个人。你把水壶放到炉子上，然后**你知道水需要一段时间才会开**。于是你**在脑子里记下“我正在等水开”这件事（保存状态）**，然后就**主动地**回到书房去看书（**暂停**烧水任务，**切换**到看书任务）。

你看书的时候，会时不时地去厨房瞄一眼水开了没有（检查I/O状态）。当你发现水开了，你就**暂停**看书任务（同样记下你看到了第几页），回到厨房把水壶拿下来。然后，你又可以回到书房，从你之前暂停的页面继续看下去（**恢复**看书任务）。

## 原理

1. **协作式调度 (Cooperative Scheduling)**：协程的暂停完全是**自愿的**。它在遇到一个耗时操作（如网络请求、文件读写）时，会主动说“我需要等一下，先让别人用CPU吧”，然后交出执行权。这与线程的**抢占式调度**（由操作系统决定哪个线程何时运行）完全不同。
2. **轻量级 (Lightweight)**：协程是在用户态实现的，它的创建、销毁和切换成本极低，基本上就是一次函数调用的开销。一个线程可以轻松管理成千上万个协程。而线程是操作系统内核级别的，创建和切换成本要高得多。
3. **状态保存 (State Preservation)**：当协程暂停时，它的所有局部变量、指令指针（执行到哪一行了）等上下文信息都会被保存起来。当它恢复时，可以完美地接着上次的状态继续执行。

## 原因

- 回调函数和回调地狱

```cpp
// 回调风格 (复杂)
downloadFile("a.txt", [](content1) {
    downloadFile("b.txt", [](content2) {
        // ... 处理 content1 和 content2
    });
});

// 协程风格 (简洁，像同步代码)
auto content1 = co_await downloadFile("a.txt");
auto content2 = co_await downloadFile("b.txt");
// ... 处理 content1 和 content2
```

### **原因 1：告别“回调地狱”，让异步代码像同步代码一样清晰**

这是最直观、最能提升开发幸福感的原因。

- **问题**：在处理需要多个步骤的异步操作时（比如：先请求用户信息，再用用户信息请求好友列表），传统的回调函数会导致代码一层层地向右嵌套，形成所谓的“回调地狱”（Callback Hell），代码难以阅读和维护。
- **协程如何解决**：协程允许你使用 `co_await` 等待一个异步操作完成，而代码本身看起来就像是普通的、从上到下执行的同步代码，逻辑非常清晰。

### **原因 2：用最少的资源实现最高的并发**

这是从性能和资源角度出发最重要的原因。

- **问题**：如果要处理成千上万个并发连接（比如一个聊天服务器），为每个连接都创建一个线程是不可行的。线程是昂贵的系统资源（占用内存多，CPU切换开销大），系统无法支持这么多线程。
- **协程如何解决**：协程非常轻量，它不是线程，只是一个可以在线程上运行的任务。一个线程可以毫无压力地管理成千上万个协程。当一个协程因为等待网络数据而暂停时，线程会立刻去执行另一个准备就绪的协程，CPU几乎没有被浪费。这使得用极少的线程就能实现极高的并发处理能力。

### **原因 3：简化复杂流程的状态管理**

这是一个更深层次的原因，但同样重要。

- **问题**：很多业务逻辑本质上是一个复杂的状态机（State Machine）。比如一个网络协议的实现，可能要经历“等待连接 -> 等待握手 -> 等待数据 -> 处理数据 -> 等待下一个数据包 -> 关闭连接”等多个状态。手动管理这些状态通常需要定义很多状态变量和 `switch-case`，非常繁琐且容易出错。
- **协程如何解决**：**协程本身就是一个隐式的状态机**。协程的局部变量就是它的“状态”，而 `co_await` 就是状态转移的触发点。你只需要按照业务逻辑写代码，编译器会自动帮你处理状态的保存和恢复，极大简化了逻辑。

## 作用

- **极大地简化异步编程**
    - 避免依赖回调函数和回调地狱
- 提高并发

## 在co_await期间, 线程在干什么

在 `co_await` 期间，线程**并不会闲着或者被阻塞**，而是被**立即释放**出来去执行其他有用的任务。这正是协程的魔力所在。

---

### **线程的具体去向**

当一个协程执行到 `co_await some_async_operation;` 这一行时，内部发生的事情可以分解为以下几个步骤：

1. **发起异步操作**：`some_async_operation` 这个操作被启动。比如，向操作系统发出一个“读取网络数据”的非阻塞请求。
    
2. **打包“未完待续”的工作**：编译器和协程库会把当前协程剩下的代码（从 `co_await` 之后到函数结束）打包成一个对象，这个对象我们称为**续体（Continuation）**。可以把它想象成一个书签，不仅记录了页码，还记录了你脑子里所有的想法（即所有局部变量的状态）。
    
3. **安排“唤醒”机制**：协程会告诉异步任务：“当你完成时（比如网络数据到达了），请调用这个‘续体’来唤醒我。”
    
4. **立即返回，释放线程**：`co_await` 表达式会**立即暂停**当前协程的执行，并**让出对线程的控制权**。

此时，线程就自由了。它会去哪里呢？主要有两种可能性：

#### **情况一（最常见）：执行另一个就绪的协程**

在一个典型的协程应用中（比如一个Web服务器），通常会有一个**调度器（Scheduler）**或**事件循环（Event Loop）**。

- 线程会立刻回到调度器，然后问：“好了，我手头这个任务暂停了，下一个该干谁的活？”
- 调度器会从一个“就绪队列”中取出另一个已经准备好运行的协程（比如另一个客户端刚刚发来了数据，或者一个计时器到期了）。
- 线程立即开始执行这个新的协程。

比喻：

你是一位顶级厨师（线程），同时烹饪10道菜（10个协程）。

你把一道菜（协程A）放进烤箱（co_await一个耗时I/O），并设置了定时器。你不会站在烤箱前傻等。你会立刻转身去处理另一道需要翻炒的菜（执行协程B），因为那道菜现在需要你的操作。你的手（CPU时间）一刻也没有停歇。

#### **情况二：返回到调用者（Caller）**

如果你的协程不是由一个复杂的调度器管理的，它可能会直接将控制权返回给最初调用它的那个函数。[^1]

C++

```cpp
Task my_coroutine() {
    std::cout << "协程开始" << std::endl;
    co_await some_long_task(); // 协程在这里暂停
    std::cout << "协程恢复并结束" << std::endl;
}

int main() {
    std::cout << "Main: 调用协程" << std::endl;
    Task t = my_coroutine(); // 1. 协程开始执行，打印"协程开始"
                             // 2. 遇到co_await，协程暂停，控制权立刻返回
    std::cout << "Main: 协程已暂停，我正在做别的事情" << std::endl; // 3. 线程现在在这里！
    // ... 在这里，主线程可以做任何其他同步工作 ...
    // ... 直到 some_long_task() 完成，并在未来某个时刻恢复 my_coroutine 的执行
}
```

**输出会是：**

```
Main: 调用协程
协程开始
Main: 协程已暂停，我正在做别的事情
(等待一段时间后)
协程恢复并结束
```

### **总结**

| **事件**         | **协程的状态**          | **线程在做什么**                      |
| -------------- | ------------------ | ------------------------------- |
| 执行到 `co_await` | **暂停 (Suspended)** | **被释放，立即去执行其他代码** (另一个协程或调用者函数) |
| 异步操作完成         | **变为就绪 (Ready)**   | 可能正在忙于其他协程。                     |
| 调度器发现协程就绪      | **恢复 (Resumed)**   | (当轮到它时) 线程回来从暂停点继续执行此协程。        |

所以，`co_await` 的本质是：**以协程的暂停为代价，换取线程的持续工作**。这是实现超高并发性能的关键，因为它确保了宝贵的线程资源永远在处理“此时此刻”就需要计算的任务，而不是在“等待”中被浪费掉。

## 无栈协程有栈协程

您好，对于您在弗吉尼亚州伍德伯恩当地时间6月18日星期三晚上9点17分提出的问题，我的回答如下：

当然，我们来简单介绍一下 C++20 引入的协程，以及“无栈”和“有栈”这两种协程的实现方式。

### 什么是协程 (Coroutine)？

首先，协程是一种比线程更轻量级的**并发编程模型**。

你可以把一个协程看作一个**可以被“暂停”和“恢复”的特殊函数**。当它执行到某个点时，可以主动暂停自己，把控制权交还给调用者，并在未来某个时刻从暂停点继续执行，而**所有的局部变量和状态都保持不变**。

这使得我们能以看似同步的、线性的方式，编写异步的、非阻塞的代码，极大地简化了异步编程的复杂性。

---

### C++20 协程：标准的无栈协程

C++20 正式将协程引入了语言标准。最重要的一点是：

**C++20 的协程是无栈协程（Stackless Coroutine）。**

它通过三个新的关键字来实现：`co_await`, `co_yield`, `co_return`。

- **`co_await`**: 用于暂停协程，等待一个异步操作完成。
- **`co_yield`**: 用于生成器（generator），可以“产出”一个值并暂停，下次再从这里继续。
- **`co_return`**: 用于从协程中返回值。

---

### 无栈协程 vs. 有栈协程

这是实现协程的两种主流技术路线，它们的底层原理和开销有天壤之别。

#### 1. 无栈协程 (Stackless Coroutine)

- 核心原理：编译器魔法。
    
    当编译器遇到一个协程函数时，它会把这个函数彻底改写成一个状态机（State Machine）。
    
    1. 你函数里的所有**局部变量**，都会被编译器打包到一个在**堆上分配**的状态机对象中。
    2. 你代码中的每一个 `co_await` 点，都成为了这个状态机的一个**状态**。
    3. 协程的“暂停”和“恢复”，实际上只是在这个状态机对象上设置当前状态，然后返回。下一次调用时，根据记录的状态跳转到对应的代码位置继续执行。
- **比喻**：就像玩一个可以随时存档的RPG游戏。你暂停（`co_await`）时，系统会把你的所有状态（等级、装备、位置等局部变量）打包成一个**存档文件**（状态机对象）存到硬盘（堆）上。下次你“恢复”时，系统加载这个存档文件，你就回到了原来的地方，所有状态都恢复了。
    
- **优点**：
    
    - **极其轻量**：一个协程的开销只是一个在堆上分配的小对象的大小，可以轻松创建数百万个。
    - **切换极快**：暂停和恢复不涉及任何操作系统的上下文切换，只是简单的函数返回和跳转，效率非常高。
- **缺点**：
    
    - **“传染性”**：一个函数要想被暂停，它自己必须是一个协程。你**不能**在一个协程中调用一个普通的同步函数，然后在那个普通函数的内部深处再暂停整个协程。
- **例子**：**C++20 协程**、**Python 的 async/await**、**Rust 的 async/await**、**C# 的 async/await** 都属于无栈协程。

#### 2. 有栈协程 (Stackful Coroutine)

- 核心原理：为每个协程分配独立的调用栈。
    
    每个有栈协程在创建时，都会被分配一块属于它自己的、完整的函数调用栈（通常大小是几KB到几MB）。
    
    - **暂停**：就是把当前CPU的执行上下文（寄存器状态、栈指针、指令指针等）保存起来，然后切换到另一个协程的调用栈上，并恢复其上下文。
    - **恢复**：过程与暂停相反。
- **比喻**：就像操作系统进行**线程切换**。每个有栈协程都像一个“用户态的轻量级线程”。
    
- **优点**：
    
    - **极其灵活**：可以在协程的**任意调用层级**进行暂停。你可以在一个协程中调用一个普通的、不知道协程存在的库函数，然后在那个库函数的内部再调用另一个函数，在最深处暂停整个协程的执行。这种能力非常强大。
- **缺点**：
    
    - **非常重量级**：每个协程都需要一个独立的、通常较大的栈内存，这使得你无法创建大量的有栈协程。
    - **切换开销较大**：虽然比真正的线程切换开销小，但保存和恢复整个调用栈的上下文，仍然比无栈协程的函数跳转要慢得多。
- **例子**：**Go 语言的 Goroutine** 是最著名的有栈协程实现。一些C++第三方库如 **Boost.Coroutine2** 也提供了有栈协程。

### 总结对比

|   |   |   |
|---|---|---|
|**特性**|**无栈协程 (C++20)**|**有栈协程 (Goroutine)**|
|**内存开销**|**非常小** (一个堆分配的状态机对象)|**大** (每个协程都有一个独立的栈)|
|**创建数量**|可以创建**数百万**个|数量受内存限制，通常是**数万或数十万**个|
|**切换开销**|**极小** (接近函数调用)|较大 (需要保存和恢复栈上下文)|
|**暂停灵活性**|**低**，只能在协程函数内 `co_await`|**高**，可以在任意函数调用层级暂停|
|**实现方式**|编译器代码转换|运行时调度，独立的调用栈|

**结论**：C++20 选择了**无栈协程**，这是一种**空间和性能上的权衡**。它放弃了有栈协程的完全调用透明性，换来了极低的内存开销和极高的切换性能，使其特别适合于需要处理海量并发连接的I/O密集型任务，如高并发网络服务器。

[^1]: 调用函数也像一个协程
