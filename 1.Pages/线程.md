---
Type:
  - Page
aliases: 
tags: 
modifiedDate: 星期六, 五月 31日 2025, 1:30:08 下午
---

## 定义

进程内的一个执行单元/路径。是 CPU 调度的基本单位（在支持线程的操作系统中）。一个进程可以包含多个线程。

## 资源拥有

**共享所在进程的地址空间和大部分资源**（如代码段、数据段、堆内存、打开的文件等）。但每个线程拥有自己的栈、寄存器集合和程序计数器。

## 并发性

同一进程内的多个线程可以并发执行。

## 创建与销毁开销

较低。创建线程通常只是分配一些线程私有的数据结构（如栈）。

## 上下文切换开销

较低。因为共享地址空间，切换时主要切换线程的私有数据（寄存器、栈指针等）。

## 通信

线程间通信更直接、方便，因为它们共享内存。可以直接读写共享变量，但需要注意同步问题。
- **共享内存 (Shared Memory / Variables):**
    - 这是最基本和直接的方式。多个线程可以直接读写进程共享内存区域中的变量（例如全局变量、静态变量、在堆上创建的对象并将其指针共享给多个线程）。
    - **关键问题：** 必须使用同步机制来避免数据竞争 (data races) 和保证数据一致性。
- **消息队列 (Message Queues / Thread-Safe Queues):**
    - 线程可以将消息（数据或任务）放入一个队列中，其他线程可以从队列中取出消息进行处理。这是经典的生产者-消费者模式。
    - 队列本身需要被设计成线程安全的，通常内部会使用互斥锁和条件变量等同步原语。
- **事件 (Events / Flags):**
    - 一个线程可以设置一个事件（或标志位），其他线程可以等待这个事件的发生。这是一种简单的线程间信号通知机制。
- **互斥锁 (Mutex / Mutual Exclusion Lock):**
    - 用于保护“临界区”（critical section），即一段访问共享资源的代码。一个线程在进入临界区前获取互斥锁，离开时释放锁。同一时间只有一个线程能持有该锁，从而保证对共享资源的独占访问。
    - 例如：`std::mutex` (C++)。
- **信号量 (Semaphore):**
    - 一个计数器，用于控制对共享资源的并发访问数量。线程在访问资源前请求信号量（计数减一），访问结束后释放信号量（计数加一）。如果信号量计数为零，请求线程会被阻塞直到有其他线程释放信号量。
    - 可用于限制并发线程数，或作为更复杂的同步原语。
- **条件变量 (Condition Variable):**
    - 允许线程等待某个特定条件变为真。通常与互斥锁配合使用。
    - 一个线程获取互斥锁，检查条件。如果条件不满足，则在该条件变量上等待（`wait`），并原子地释放互斥锁。当另一个线程改变了共享数据使得条件可能满足时，它会通知（`notify_one` 或 `notify_all`）正在等待该条件变量的线程。被唤醒的线程会重新获取互斥锁并再次检查条件。
    - 例如：`std::condition_variable` (C++)。
- **读写锁 (Read-Write Lock):**
    - 允许多个线程同时读取共享数据，但只允许一个线程写入共享数据。当有线程正在写入时，其他所有读取和写入操作都会被阻塞。当没有写入操作时，可以有多个读取操作并发进行。
    - 适用于读多写少的场景，可以提高并发性。
    - 例如：`std::shared_mutex` (C++17)。
- **原子操作 (Atomic Operations):**
    - 对于简单的共享变量（如整数、布尔值、指针）的原子性读写操作。原子操作是不可分割的，可以避免使用锁带来的开销，并简化某些并发场景下的代码。
    - 例如：`std::atomic<T>` (C++)。
- **`std::future` 和 `std::promise` (C++):**
    - 用于在线程间传递异步操作的结果。一个线程（通常是执行异步任务的线程）通过 `std::promise` 设置一个值（或异常），另一个线程可以通过关联的 `std::future` 对象在未来的某个时间点获取这个值（或异常）。

## 健壮性/隔离性

一个线程崩溃（如未捕获的异常、非法内存访问）通常会导致整个进程崩溃，因为它们共享地址空间。

## “重量级” Vs “轻量级”

通常被称为“轻量级进程”。
