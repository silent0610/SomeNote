---
Type:
aliases: 
tags: 
modifiedDate: 2025/06/18, 17:01:31
---

# 类型转换面经

## 类型转换

- C++的几种cast。[C++Cast](C++Cast.md)
    - 哪一种cast与C中的cast相同？
    - ***并且其行为可能等同于 C++ 提供的多种特殊 `cast` 中的任何一种***，导致代码意图不明确。因此，在 C++ 中**不推荐**使用 C 风格的转换。
- 介绍一下c++中的强制类型转换？
    - [[C++Cast]]
- 使用static_cast与dynamic_cast，从派生类向基类的转换怎么实现？
    - [[C++static_cast#怎么进行向上转型?|static_cast]]
    - 第一点：在进行上行转换的时候，二者的效果是一样的；区别在于下行转换
        - dynamic_cast：先检查两个类型有继承关系，然后检查类型转换是否合法，基类转化成派生类的转换（基类指针指向基类对象）是不合法的，会导致返回一个nullptr。
            - 在进行向上转换的时候，不要求类中必须存在虚函数表
            - （向下转换需要多态：虚函数表）在进行向下转换（基类指针指向派生类对象）的时候，类中必须要存在虚函数表，dynamic_cast认为此时转换才有意义；否则无法通过编译。
        - static_cast：可以通过编译，但基类向派生类的转换之后可能会导致未定义的行为。
- static_cast与dynamic_cast的开销和区别？
    - static_cast在编译期完成，dynamic_cast在运行时完成。
    - 大量使用dynamic_cast会造成性能下降，在确定实际类型的时候，使用static_cast更加高效。
- 介绍一下dynamic_cast的细节？
    - 当两个类具有继承关系的时候，我们可以进行向下转换，这个向下转换的过程很多时候是不安全的。
    - c++的RTTI（runtime type identify，执行期类型识别）提供了一个安全的向下转型方法，但是只针对多态类型（继承和动态绑定）有效。其中具体策略是：在c++虚函数表的第一个slot中，放置一个指针，指向type_info类对象。
    - 对于指针类型的转换
        - 如果转换成功，则返回转换后的指针
        - 如果转换失败，则返回nullptr
        - 将转换语句放置在if中来进行判断，从而采取不同措施。
    - 对于引用类型的转换
        - 如果引用可以转换为适当的子类，则可以继续执行
        - 如果无法进行转换，则会抛出bad_cast异常
        - 通常使用try-catch来判断转换是否成功。
- 介绍一下type_id运算符？
    - 用于在**运行时**获取一个表达式或类型的**类型信息**，常配合 `<typeinfo>` 头文件中的 `std::type_info` 一起使用。
    - 可以传入引用，来获得一个type_info的常量引用。
    - 对于内置类型、非多态类型，type_info是编译期取得的。
    - 对于多态类型（具有虚函数表），type_info是执行期取得的。
