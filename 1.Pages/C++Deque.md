---
Type: 
aliases:
  - std::deque
tags: 
modifiedDate: 2025/06/16, 14:43:09
---

# C++Deque

## 定义

`std::deque` 的全称是 **Double-Ended Queue**，即 **双端队列**。

它是一个序列容器，就像 `std::vector` 和 `std::list` 一样，用于存储一系列的元素。其最核心的特性是：**它支持在容器的头部和尾部进行高效的（常数时间复杂度）插入和删除操作**。

你可以把 `std::deque` 想象成是 `std::vector` 和 `std::list` 的一种混合体或折中方案，它试图结合两者的优点。

## 实现

**不是一块连续的内存**
1. deque：双向开口的逻辑连续空间，能够提供O(1)的头尾插入、删除。
    - 当在**尾部**插入一个新元素，且当前最后一个内存块已满时，`deque` 只需申请一个新的小内存块，并将新块的地址存入中控映射即可，**无需移动所有旧元素**。
    - 当在**头部**插入一个新元素，且当前第一个内存块已满时，同样只需申请一个新内存块，并将其地址存入中控映射的“前面”（如果中控映射本身也是一个动态数组，可能需要移动指针，但这个开销远小于移动所有数据元素）。
2. deque没有capability的概念，以**分段连续空间**组合而成，随时可以增加⼀段新的空间并连接起来。
3. deque 是如何做到维护整体连续的假象的：deque 采⽤⼀块所谓的map 作为主控，这⾥的 map 实际上就是**指针数组**，其中每⼀个元素（我们称之为节点 node）都指向了另⼀段连续线性空间（称为缓冲区），这些缓冲区才是 deque 的真正存储空间。

### 头部插入 (`push_front`) 的实现

>  在头部插入导致需要分配一个**新内存块**时，`start` 迭代器会被设置指向这个新内存块的“**末尾**”附近。

`push_front` 的逻辑与 `push_back` 完全对称，只是所有操作都发生在**头部**。

#### 情况一：当前头部内存块有剩余空间

- **检查**: `deque` 发现其 `start` 迭代器指向的第一个内存块的**前面**还有空闲位置。==（`start` 通常不会指向块的绝对开头，除非头部也插满了）。==
- **比喻**: 火车的第一节车厢前面还有预留的空座位。

**实现步骤：**

1. **更新迭代器**: 将 `start` 迭代器**向前**移动一位，指向那个空闲的内存位置。
2. **定位**: 找到 `start` 迭代器现在指向的位置。
3. **原地构造**: 在这个位置上直接构造新元素。

这个过程也是严格的 **O(1)** 操作。

**示意图：**

#### 情况二：当前头部内存块已满

当 `start` 迭代器已经指向第一个内存块的起始位置时，就需要扩容了。

- **检查**: `deque` 发现第一个内存块的前面已经没有空间了。
- **比喻**: 火车的第一节车厢坐满了，你需要在车头**再挂一节新的空车厢**。

**实现步骤：**

1. **分配新内存块**: 在堆上申请一个**全新的、固定大小的内存块**。
2. **更新块映射表**: 在中控的“块映射表”的**开头**，增加一个新的指针槽位，让它指向新内存块。
3. **更新 `start` 迭代器**: 将 `start` 迭代器**重置**，==使其指向这个**新内存块的末尾**。==
4. **原地构造**: 在 `start` 指向的新位置上构造元素。

## 性能

1. 头尾插入、删除为O(1)
2. 随机访问为O(1)
