---
Type: 
aliases:
  - Virtual Texture
tags: 
modifiedDate: 2025/06/25, 20:24:33
---

# 虚拟纹理

## 定义

**虚拟纹理（Virtual Texturing）** 是一种用于处理 **超大纹理** 的技术，它允许你在 GPU 显存较小的情况下，使用远远大于显存容量的纹理资源，例如 **32K×32K** 或更大尺寸的地形、角色或场景纹理。

>  核心思想是将一个巨大的纹理分割成许多个小块（称为“瓦片”或“页面”），然后只在需要时，才将当前摄像机视野内可见的瓦片动态地从硬盘或固态硬盘加载到显存中。

## 实现原理

会分配一个巨大的虚拟纹理，并对整个mipmap链在虚拟内存和物理内存中划分为若干个tile。几何图形在虚拟纹理中使用全局的uv参数化，并且在像素着色器中使用这样的uv坐标之前，它们会被转换为指向实际物理纹理内存的纹理坐标。

- **解决的问题**：在传统的三维游戏或应用中，如果一个物体需要非常精细的表面细节 (比如一张地图)，就需要一张分辨率极高的纹理图片。比如，一张 16K（16384x16384像素）的纹理可能占用接近1GB的显存。如果场景中有多个这样的物体，显存会很快被耗尽，导致程序崩溃或性能急剧下降。
- **工作原理**：虚拟纹理技术就是为了解决这个显存瓶颈。它并不一次性把整张巨大的“世界地图”纹理加载进来，而是：
    - **预处理（Pre-processing）**：首先，将这张巨大的原始纹理（例如 16K 分辨率）预先切分成无数个小尺寸的瓦片（Tiles），比如每个瓦片是 256x256 像素，并为这些瓦片创建不同细节层次的版本（Mipmaps）。
    - **动态加载（Dynamic Loading）**：在程序运行时，系统会根据摄像机的位置和朝向，实时计算出当前画面需要显示哪些部分的纹理。
    - **按需“串流”（Streaming）**：系统只把计算出的、当前“看得见”的那些瓦片从速度较慢的硬盘（HDD/SSD）加载到速度极快的显存中。当摄像机移动，视野发生变化时，系统会丢弃不再需要的旧瓦片，并加载新的瓦片进来。

> [!NOTE]- 为什么是 MipMap?
> 当一个物体距离摄像机很远时，它在屏幕上可能只占几十个像素。此时，如果还去加载它那张巨大的、高清的纹理瓦片，会造成巨大的浪费：
> - **浪费带宽**：从硬盘读取了大量永远不会被显示出来的像素数据。
> - **浪费显存**：在宝贵的显存中放入了过高精度的纹理。
> - **造成画面闪烁（Aliasing）**：GPU 为了把几千个像素挤进几十个像素的空间里，会进行非常困难的“猜测”和采样，导致画面出现锯齿、摩尔纹或闪烁。
> - 而有了 Mipmap，系统就可以做出智能判断：“哦，这个物体在远处，我只需要加载它 Mipmap 链中那张 128x128 像素的低清版本对应的瓦片就足够了。” 这就完美匹配了“按需加载”的原则，确保了加载的数据不多不少，恰到好处。

## 得失

- 得
    - 支持超大纹理
    - 降低显存占用
    - 简化美术工作流程
    - 可能加快加载速度
- 失
    - 实现复杂
    - CPU 开销
    - 延迟问题
