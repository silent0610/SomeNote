---
Type: 
aliases:
  - Constructor
tags: 
modifiedDate: 2025/06/13, 19:45:31
---

# C++构造函数

## 定义

在 C++ 中，**构造函数(Constructor)**是一种特殊的**成员函数**，它的核心职责是**初始化（Initialize）**一个新创建的对象。当一个类的对象被创建时，构造函数会自动被调用，以确保对象在诞生之初就处于一个有效的、可用的状态。

> 请确保构造函数执行完成后,对象是完整的,而不需要进行其它的初始化操作

## 作用

- **初始化成员变量**：给对象的各个成员变量赋予一个合理的、确定的初始值，防止使用未初始化的变量导致程序出错。
- **分配必要的资源**：如果对象需要管理某些资源（如动态分配的内存、打开的文件、网络连接等），构造函数是执行这些资源分配操作的理想场所。这正是 **RAII（资源获取即初始化）**思想的体现。
- **调用基类的构造函数**：在派生类中，构造函数负责调用其基类的构造函数，以完成对象基类部分的初始化。
- **执行其他必要的逻辑**

## 分类

```C++
class Data
{
public:
  Data() = default;                      // 默认构造函数（⽆参构造函数）
  Data(int a, int b) :a_(a), b_(b) {};   // 一般构造函数
  Data(int ab) :Data(ab, ab) {};         // 委托构造函数
  Data(const Data& data) = default;      // 拷贝构造函数  
  Data(Data&& data) noexcept = default;  // 移动构造函数
  explicit Data(ClassA& another_class);  // 类型转换构造函数
private:
  int a_;
  int b_;
};
```

### 默认构造函数（⽆参构造函数）

一个可以**不带任何参数**就被调用的构造函数。如果你没有定义任何构造函数，编译器通常会为你生成一个。
- 可以使用 [[C++11#^8437f4|=default]] **"请求"**编译器生成一个默认构造函数,但是==具体是否生成需要看类的实现==
  以下情况不能生成
    - 成员变量没有默认构造函数
    - 基类没有默认构造函数
    - 含有引用成员或未初始化的 const 成员
    - 成员或基类的析构函数/构造函数不可访问或被删除

### ⼀般构造函数

> 普通的构造函数

也叫做重载构造函数，⼀般构造函数可以有各种参数形式，⼀个类可以有多个⼀般构造函数，**前提是参数的个数或者类型不同**，创建对象时根据传⼊参数不同调⽤不同的构造函数。

### 委托构造函数

- [[C++11]] 引入
- 即使用该类的其他构造函数来执行自己的初始化过程。

```cpp
class A
{
public:
    int data1;
    int data2;
    A() :data1{ 10 }
    {
        ;
    }
    A(int data) :A()
    {
        data2 = data;
    }
};
```

==需要注意的是,如果一个构造函数使用了委托构造,就不能有其它初始化列表==
即下面代码是错误的

```cpp
A(int data) :A(), data2{data} // 报错, 委托构造函数不能具有其它成员初始化表达式
{
}
```

> 委托构造函数不能具有其它成员初始化表达式

### 拷贝构造函数

**⽤于根据⼀个已存在的对象复制出⼀个新的同类对象**

- 第一个参数必须为对象本身的（左值）引⽤，且其他任何额外参数都需要具有默认值，⽤于根据⼀个已存在的对象复制出⼀个新的同类对象。
- 如果没有显式声明拷⻉构造函数，那么系统会**默认创建⼀个拷⻉构造函数**，⼀般在函数中会将已存在的对象的数据成员的值⼀⼀复制到新创建的对象中。
- 当类中包含指针成员的时候，**最好不要使⽤**编译器提供的默认的拷⻉构造函数，最好⾃⼰定义并且在函数中执⾏**[[深拷⻉和浅拷贝|深拷贝]]**。

### 移动构造函数

用于将一个对象的资源移动到当前对象中，同时还要确保源对象不再指向被移动的资源。**且源对象不再作为完整对象被使用**

- 第一个参数为对象本身的右值引用，且其他任何额外参数都需要具有默认值。用于将一个对象的资源移动到当前对象中，同时还要确保源对象不再指向被移动的资源。
- 移动构造函数不会分配任何新内存，它会接管传入对象的资源。最终移动后的对象会被销毁。
- 移动构造函数通常不会抛出任何异常，使用**noexcept**进行标记。
- 只有当一个类没有定义任何自己版本的**拷贝控制成员**，并且类中的**每个非static成员都可以移动**时，编译器才会为这个类合成一个移动构造函数。
- **如果我们定义了一个拷贝构造函数、拷贝复制运算符或者析构函数，那么编译器不会为这个类合成移动构造函数**。如果一个类没有移动操作，会通过正常的函数匹配，使用对应的拷贝操作来代替移动操作。

#### 什么时候要声明移动构造函数

[[C++五法则]]

#### 什么时候编译器不会合成移动构造?

- 自定义了拷贝构造函数或拷贝赋值运算符
- 显式地声明了析构函数
- 自己实现了移动构造 或者 已经声明了移动构造函数，但**没有定义它**
- 类中包含不能移动的成员(static 不算)
- 将移动构造函数显式标记为 `= delete`

### 类型转换构造函数

根据⼀个指定类型的对象，创建出⼀个本类的对象，也可以算是⼀般构造函数的⼀种。有的时候我们不允许进行隐式转换的话，要记得将其声明为 explict 的，来阻⽌⼀些隐式转换的发⽣。
