---
Type:
aliases: 
tags: 
modifiedDate: 2025/06/26, 20:23:52
---

# DepthSDFLog

## 6

### 6.26

- Unity 导出的 3 维矩阵和我理解的数据有误差
- 确定 unity 中使用 GPUAsync 导出为按 unity 左手坐标系的, 从左下前 (面前摆放着一个立方体, 离我近的面为前, 离我远的面为后)到右上后. 
- [[Python]] 中使用 numpy 读取并 reshape 后确定为 z, y, x. 即 `mat[0,:,:]` 为最前面的那一切片
- numpy 这样定义矩阵是 z, y, x, 

```
Gz_kernel = np.array([
    [[0, 0, 0],
     [0, -1, 0],
     [0, 0, 0]],
     
    [[ 0,  0,  0],
     [ 0,  0,  0],
     [ 0,  0,  0]],
     
    [[ 0,  0,  0],
     [ 0,  1,  0],
     [ 0,  0,  0]]
],)
```

- 使用 `mat[0,:,:]` 读取到的为 

```
[[0, 0, 0],
 [0, -1, 0],
 [0, 0, 0]],
```

- 由于 Untiy 读出的是左手系, 通过 `sdf_volume = sdf_volume[::-1, :, :]` 转换为右手系
- scipy 的 convolve 会取反? 使用 correlate 替代
- 不管了, 反正计算的是对的. 3d可视化错了就错了吧

总而言之，平滑（如Sobel算子中的）主要好处是**牺牲最顶尖的细节响应，来换取强大的噪声抑制能力和梯度方向的稳定性**。

它不会帮您“跳”得更远，但能确保您跳的每一步都踩在更坚实、更可靠的方向上。在需要根据梯度移动点（如粒子模拟、基于梯度的优化）的应用中，**方向的正确性**和**稳定性**往往比步长的大小更重要。

![[assets/SobelSdf切片-1.png]]

![[assets/基础SDF梯度-1.png]]
