---
Type:
  - Page
aliases:
  - Shading
tags: 
Status: 
modifiedDate: 星期三, 六月 4日 2025, 10:36:22 晚上
---

## 着色

shading：给物体施加材质的过程。包括光照和texture。  

### 可见性，Z-buffering

深度缓存  

### Blinn-Phong反射模型

specular高光：与观察方向有关，反射

diffuse漫反射：与观察方向无关，光线打过来，均匀地反射到四面八方。只与光线与法线夹角有关

ambient环境光：可以设置为常数

这里的光线考虑衰减，I/r^2，实际衰减的是irradiance（单位面积的光的power）  

### Shading Frequency

对面shading（flat），对每一个面着色

对vertex做shading（gouraud），对每一个顶点着色，对内部区域做插值（二次插值）

对像素做shading（phong shading），对每个像素着色  

### 图形渲染管线

 1. MVP变换  

  1. Model 在空间中找到对应点  

  2. view 调整摄像机位置，方向等  

  3. projection 投影到屏幕空间  

三维空间顶点经过mvp矩阵变换，变成屏幕空间的顶点。

屏幕空间的顶点，经过三角形处理，组成三角形。

三角形经过光栅化，变成fragment。

fragment经过shading，计算光照、纹理映射（比如采用布林冯模型、微表面模型，就在此处进行相应的计算），变成fragment。

带材质的fragment经过framebuffer（比如深度处理），变成屏幕上的图像。

\*具体过程是，先进行mv矩阵变换，然后对顶点进行着色（包括法向量、纹理坐标、颜色等），之后投影矩阵变换，得到一个标准化立方体（正交投影得到标准立方体好理解，但其实透视投影得到的也是标准立方体，经过压缩之后的），之后经过视锥剔除这一步操作，避免不必要的时间消耗，此时得到的还是标准化立方体，顶点的坐标还是三维的，然后经过视口变换，得到对应屏幕大小的二维图像，此时的顶点包括所有需要的信息（包括法向量、纹理坐标、颜色等）。然后进入光栅化阶段，先进行三角形处理，对顶点与顶点之间做插值，然后做光栅化，对应到像素，然后做shadding（包括纹理映射），对像素着色，之后做可视化处理、alpha测试、模板测试等，上屏到显示设备。  

### 材质映射

### 重心坐标，用来做插值

### Texture Magnification

如果纹理太小怎么办？纹理上一个texel被图像上多个pixel包含，texel不够用。

方法：用插值的方法补texel！近邻、双线性、双次立方。

如果纹理过大怎么办？图像一个pixel包含多个texel（摩尔纹）。

方法：mipmap。mipmap的好处，额外的内存开销小，只有原来的三分之一；缺点，只能对正方形区域查询，有的pixel包括的texel是斜着的一条区域，mipmap仍然不能表现该区域的属性。

改良：ripmap，各向异性过滤，开销是原来的三倍。  

### 材质的应用

环境贴图、环境光（包括很多游戏大作的画面非常好，有些就是提前计算好光照，做成光照贴图）、

\*环境贴图可以是球面或立方体面

纹理不只可以表示颜色，也可以表示高度/法向量（bump/normal），只是影响了shading计算，没有真正地改变顶点的位置。用displacement mapping，可以实际上改变顶点的位置。（bump/normal这一步，纹理影响shading，作用于fragment，在fragment做shading的阶段进行处理；而如果是displacement，应该是顶点处理阶段进行。看来，着色频率的选取跟纹理贴图的应用有实际的对应关系。）

三维噪声函数定义纹理，在任意点都能取得相应的值。（参考隐式的几何表达。）
