---
Type:
aliases: 
tags: 
modifiedDate: 2025/06/13, 16:42:10
---

# RenderDoc 的 Hook 是怎么实现的？

- 整体思路：修改目标进程的内存，将需要Hook的目标函数地址替换成自己的函数地址，从而捕获对目标函数的调用。
    下面是一种方法：
    1. 对头文件进行分析，找到虚函数的偏移
    2. 获取虚函数表指针，找到虚函数表，根据偏移量找到目标函数
    3. 修改目标函数的地址，替换成自己的函数，从而对目标函数进行捕获。

## 具体

- **对于 DirectX (D3D11/12)**
    - **策略**：**偷梁换柱**。
    - **做法**：当游戏说“请给我一个D3D设备”时，RenderDoc 会先创建一个真正的D3D设备，然后把它藏起来。接着，它会仿造一个**一模一样的“假”设备**交给游戏。这个假设备的所有“按钮”（虚函数）都被RenderDoc换掉了，按下去会先通知RenderDoc，然后再由RenderDoc去按那个真设备上对应的按钮。
- **对于 Vulkan**
    - **策略**：**合法登记**。
    - **做法**：Vulkan API 的设计非常现代化，它天生就有一个官方的“访客登记处”（叫做 **Layers/层**）。RenderDoc 只需要像一个普通访客一样，去那里合法登记一下，之后所有进出这个“大楼”的API调用都会被记录在案。这是最干净、最标准的方式。
- **对于 OpenGL**
    - **策略**：**门卫盘查**。
    - **做法**：OpenGL 比较老式，没有统一的“前台”。RenderDoc 就守在几个关键的“大门口”（比如 `wglSwapBuffers` 和 `wglGetProcAddress` 函数）。当游戏要显示画面或者查询某个功能的地址时，RenderDoc 就会把它拦下来，记录信息，并给它一个处理过的“通行证”或地址。
