---
Type:
  - Page
tags:
---
[数据结构与算法](数据结构与算法.md)

- 代码示例
```cpp
void bubbleSort(std::vector<int>& arr) {
    int n = arr.size();
    int lastSwap = n - 1;
    
    for (int i = 0; i < n - 1; ++i) {
        bool swapped = false;
        int currentSwap = -1;
        
        for (int j = 0; j < lastSwap; ++j) {
            if (arr[j] > arr[j + 1]) {
                std::swap(arr[j], arr[j + 1]);
                swapped = true;
                currentSwap = j;
            }
        }
        
        if (!swapped) break; // 提前终止
        lastSwap = currentSwap; // 缩小范围
    }
}
```

- **最佳时间复杂度**：O(n)。最好的情况下（初始时序列已经是升序排列），只需经过 11 趟排序，总共经过 nn 次元素之间的比较，并且不移动元素，算法就可以结束排序。因此，冒泡排序算法的最佳时间复杂度为 O(n)O(n)。
- **最坏时间复杂度**：$O(n^2)$。最差的情况下（初始时序列已经是降序排列，或者最小值元素处在序列的最后），则需要进行 n 趟排序，总共进行 n(n−1)​/2 次元素之间的比较，因此，冒泡排序算法的最坏时间复杂度为 $O(n^2)$ 。
- **空间复杂度**：O(1)。冒泡排序为原地排序算法，只用到指针变量 i、j 以及标志位 flag 等常数项的变量。
- **冒泡排序适用情况**：冒泡排序方法在排序过程中需要移动较多次数的元素，并且排序时间效率比较低。因此，冒泡排序方法比较适合于参加排序序列的数据量较小的情况，尤其是当序列的初始状态为基本有序的情况。
- **排序稳定性**：由于元素交换是在相邻元素之间进行的，不会改变相等元素的相对顺序，因此，冒泡排序法是一种 **稳定排序算法**。
