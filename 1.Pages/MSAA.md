---
Type:
  - Page
aliases: 
tags: 
modifiedDate: 2025/06/24, 15:17:31
---

# MSAA

相比于 [SSAA](SSAA.md) 它同样需要保存 N (和之前的 N 倍分辨率不一样)个样本的 color 和 zbuffer
所以
- 增加 N 倍带宽需求
- 但是, 它减少了计算负载
	- 一个片元只被计算一次,
	- 假如某个三角形与当前像素重合
		- 计算该三角形与当前像素所有子样本样本的重合情况, (以及深度测试) 如果没有重合, 直接返回
			- 如果这个三角形与像素中心重合, 在像素中心计算一次
			- 否则, 根据重合情况, 调整计算位置, 但也只计算一次.
	- 由于这种计算方式, **每个片元** (每个与像素重合的三角形都会生成**一个**片元)只需要被着色一次, 而 SSAA 需要 $N^2$ 次, 大大减少了计算量
- 每个样本都保存 z , 也需要进行 earlyZ

## 细节

### 采样模式

可以有不同的采样点的分布和数量

### 深度/模板采样

每个子像素位置存储独立的深度和模板值。
所以有 N 倍的 Depth 开销

### 颜色 Buffer

需要保存每个像素上所有子像素的着色结果, 也有 N 倍的开销

### 混合

最后混合的时候混合所有子像素结果

## 开销

假如 4xMSAA
- 带宽和内存
    - color buffer \*4
    - depth buffer \*4
- 光栅化阶段 \*4 ,需要为每个子像素计算覆盖信息
- **像素着色不会有四倍**: 通常每个片元只执行一次

## 优缺点

- [MSAA与延迟渲染管线兼容性差](MSAA与延迟渲染管线兼容性差.md)

#注意
- RTR4 5.4.2 节5.26 图附近关于 MSAA **Pixel Shader 计算位置的选择**的表述
	- 中心重合则在中心计算. 
	- 如果所有的样本位置都被这个片元所覆盖，那么则在像素的中心位置来计算这个着色样本；
- 应该按第一个为准, 即 ***中心重合则在中心计算***. 
