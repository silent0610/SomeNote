---
Type:
  - Page
aliases: 
tags: 
Status:
modifiedDate: 2025/07/05, 17:13:00
---

# 图形API对比

[游戏引擎岗面经](游戏引擎岗面经.md)

## 基本分类

- 现代 API
	- Vulkan
	- DX12
	- Metal
- 传统 API
	- OpenGL
	- DX11

## 区别

总的来说，Vulkan 等现代 API 的设计哲学是：**更低的抽象，更显式的控制，更低的驱动程序开销，更好的多线程支持，以及更高效的硬件利用。**

这使得开发者能够编写出性能更高、更稳定、更可预测的图形应用程序，特别是在需要榨取每一分 GPU 性能的 AAA 游戏和专业图形应用中。然而，这种能力的**代价是更高的学习曲线和更复杂的开发工作**。开发者需要对 GPU 架构和渲染管线有更深入的理解。

### 1. 控制权与抽象层级

- **老 API (OpenGL):** 是**高层抽象**，像个“黑盒”。它隐藏了大量硬件细节，通过**状态机**模型隐式管理 GPU。开发者告诉它“做什么”，具体“怎么做”由驱动程序决定。
- **现代 API (Vulkan):** 是**底层、显式控制**。它暴露了更多硬件细节，开发者需要明确管理所有资源、状态和操作。你直接告诉 GPU **每一步**要做什么，驱动程序只负责执行，像给 GPU 写汇编。

---

### 2. 性能与 CPU 开销

- **老 API:** 驱动程序承担大量优化和翻译工作，导致**高 CPU 开销**，容易成为性能瓶颈，尤其在多线程下。性能可能因驱动版本而异，有不确定性。
- **现代 API:** 大部分工作下放给开发者，减少 cpu 验证工作, 显著降低了**CPU 开销**。驱动程序更轻量，性能更可预测、稳定，适合多线程并行提交命令。

---

### 3. 内存与管线管理

- **老 API:** 内存管理**隐式自动化**，开发者对显存布局和分配控制少。管线状态是**动态**的，频繁切换状态可能导致性能下降。
- **现代 API:** 内存管理**显式且细粒度**，开发者手动分配和绑定显存，可优化内存布局。管线状态是**不可变对象 (PSO)**，一次性创建，运行时切换 PSO，避免了运行时编译和验证开销。

---

### 4. 同步与着色器

- **老 API:** 同步多为**隐式**，驱动程序可能插入不必要的同步，导致 GPU 空闲。着色器在运行时由驱动编译。
- **现代 API:** **显式同步**，开发者需精确控制任务顺序和数据可见性（通过 Barrier、Semaphore、Fence）。着色器使用 **SPIR-V 中间表示**，预编译后提供给 GPU，减少运行时开销，并增强跨平台一致性。

## 详细版

### 1.显式控制 Vs. 隐式抽象

- **OpenGL (及早期 DirectX):** 属于**高层抽象 API**。它隐藏了大量的底层硬件细节，提供了一个相对简单易用的状态机模型。开发者通过改变全局状态来控制渲染管线。例如，调用 `glEnable(GL_DEPTH_TEST)` 会改变一个全局的深度测试状态。这种方式对初学者友好，但开发者对 GPU 内部的实际工作方式缺乏控制。
    
- **Vulkan (及现代 API):** 属于**底层、显式 API**。它将更多的控制权交给了开发者。你不再操作一个全局状态机，而是显式地创建和管理所有的 GPU 资源（如缓冲区、图像、描述符集）、管线状态（如混合、深度测试配置）、命令提交等。这意味着你需要明确地告诉 GPU 每一步要做什么，以及数据如何流动和同步。
    
    - **例子：** 在 OpenGL 中，你调用 `glBindTexture` 绑定纹理，然后 `glDrawArrays` 绘制。Vulkan 中，你需要创建 `VkImage`、`VkImageView`、`VkSampler`，将其绑定到 `VkDescriptorSet`，然后通过 `VkPipelineLayout` 和 `VkGraphicsPipeline` 组织这些资源，最后在一个 `VkCommandBuffer` 中记录这些命令。

### 2. 驱动程序开销与 CPU 瓶颈

- **OpenGL:** 驱动程序承担了大量的职责，负责将高层 API 调用翻译成底层硬件指令。这意味着驱动程序需要进行很多猜测、优化和状态验证工作。这可能导致：
    - **高 CPU 开销：** 大量的 API 调用和状态切换会导致 CPU 成为瓶颈，尤其是在复杂的场景和多线程环境下。
    - **不确定性：** 驱动程序的优化可能在不同硬件和驱动版本上表现不一致，导致渲染行为或性能不可预测。
    - **隐式同步：** 驱动程序经常需要插入隐式同步来确保操作的正确性，这可能导致 GPU 泡（idle time）。
- **Vulkan:** 将大部分底层管理和优化工作下放给开发者。这意味着：
    - **低 CPU 开销 (CPU Overhead):** 驱动程序的工作量大大减少，主要负责将开发者明确定义的命令提交给 GPU。这显著降低了 CPU 的瓶颈。
    - **确定性：** 由于显式控制，渲染行为和性能的可预测性更高。
    - **显式同步：** 开发者必须显式地管理所有同步，避免了驱动程序插入不必要的同步。

### 3. 多线程支持

- **OpenGL:** 主要是**单线程 API**。虽然有些扩展允许在不同上下文中使用多线程，但核心设计是基于一个渲染线程。这意味着主线程常常需要等待图形命令的完成，限制了并行处理的能力。
- **Vulkan:** 从设计之初就考虑了**多线程渲染**。它允许在多个线程中同时记录命令缓冲区（`VkCommandBuffer`），然后由一个主线程提交到队列。这使得游戏引擎可以：
    - **并行记录命令：** 不同的CPU核心可以并行准备渲染命令，充分利用现代多核 CPU。
    - **减少瓶颈：** 将渲染命令的准备工作分散到多个线程，从而缓解了 CPU 主线程的压力。

### 4. 内存管理

- **OpenGL:** 内存管理相对**自动化和隐式**。开发者通常通过 `glGenBuffers`、`glTexImage2D` 等函数创建资源，驱动程序负责在显存中分配和管理内存。开发者对内存的分配策略和布局没有直接控制。
    
- **Vulkan:** 提供了**显式和细粒度的内存管理**。开发者需要：
    
    - **查询内存类型：** 根据资源用途（如顶点缓冲区、纹理）和硬件特性，查询合适的内存类型（例如，设备本地内存、主机可见内存）。
    - **显式内存分配：** 调用 `vkAllocateMemory` 手动从合适的内存堆中分配内存。
    - **内存绑定：** 将创建的资源（`VkBuffer`、`VkImage`）与分配的内存对象进行绑定。
    - **内存映射：** 如果需要 CPU 访问 GPU 内存，需要显式地进行内存映射。
    - **持久映射：** 现代引擎通常会使用持久映射的缓冲区来优化 CPU-GPU 数据传输。
    
    这种控制允许开发者根据具体需求优化内存布局，例如，将频繁访问的数据放在连续的内存区域，提高缓存效率（数据局部性）。

### 5. 管线状态对象

- **OpenGL:** 管线状态是**动态且分散**的。你可以在任何时候修改管线状态（如开启/关闭混合、修改深度测试函数），这些修改会立即生效，并且需要驱动程序在后台进行验证和重编译管线。频繁的状态切换会导致性能下降。
- **Vulkan:** 引入了**不可变管线状态对象 (Pipeline State Objects - PSOs)**。你需要在创建图形管线（`VkGraphicsPipeline`）时一次性指定所有管线状态（着色器、混合、深度测试、光栅化等）。一旦创建，这个 PSO 就是不可变的。
    - **优点：** 驱动程序在管线创建时就可以进行所有的编译和验证工作，运行时无需再进行昂贵的状态检查和重编译。
    - **缺点：** 灵活性下降，如果需要切换一两个状态，可能就需要创建并切换到另一个 PSO，但现代引擎通常会通过管线缓存或管线生成器来缓解这个问题。
    - 当然, 存在一些动态 state, 比如视口和 scissor

### 6. 渲染通道 (Render Passes) 和子通道 (Subpasses)

- **OpenGL:** 没有明确的渲染通道概念。开发者通过 `glFramebufferTexture2D` 等将纹理附加到帧缓冲区，然后进行绘制。
- **Vulkan:** 引入了**渲染通道 (Render Pass)** 概念。它描述了一组附件（颜色、深度、模板缓冲区）以及在这些附件上执行的一系列渲染操作（**子通道**）。
    - **优点：** 允许驱动程序提前知道渲染过程的所有依赖关系和附件布局转换，从而进行更深度的优化（如 Tiled Rendering 架构的 GPU 可以更好地利用片上缓存），减少内存带宽消耗。
    - **子通道依赖 (Subpass Dependencies):** 显式地定义子通道之间的依赖关系，确保数据在不同子通道之间正确传递和同步。

### 7. 着色器管理

- **OpenGL:** 采用 GLSL 源代码作为着色器输入，驱动程序在运行时编译着色器。这可能导致：
    - **编译时间长：** 首次运行时需要编译着色器。
    - **编译错误：** 运行时才发现着色器错误。
    - **驱动依赖：** 编译器质量和优化效果因驱动而异。
- **Vulkan:** 使用**中间表示 (Intermediate Representation)**，特别是 **SPIR-V**。开发者通常在开发阶段预编译 GLSL 或 HLSL 代码为 SPIR-V 字节码，然后在运行时直接提供给 Vulkan。
    - **优点：**
        - **跨平台兼容：** SPIR-V 是一个开放标准，独立于具体硬件和驱动。
        - **更快的加载：** 运行时省去了着色器编译过程。
        - **确定性：** 避免了运行时着色器编译的驱动差异。
        - **工具链友好：** 方便进行着色器优化、分析和检查。
