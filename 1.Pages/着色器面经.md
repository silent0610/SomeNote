---
Type:
aliases: 
tags: 
modifiedDate: 2025/06/20, 16:17:39
---

# 着色器面经

## 顶点着色器的作用 ？什么样的内容写在顶点着色器里？

- 程序员可控制的一个着色器阶段
- 顶点变换: 计算任何逐顶点数据. 如位置, 颜色, 法线, uv 等. 通常顶点着色器程序会将顶点从模型空间变换到齐次裁剪空间中，在最极端的情况下，顶点着色器也必须要输出顶点的位置。
- 对物体进行变形, 如常用的蒙皮技术, 来设置角色的身体动画颌面部动画
- 程序化变形: 例如旗帜, 布料和谁面的运动
- 利用顶点着色器实现全屏 pass

## 顶点着色器中坐标系的变化是怎样的？，是否必须要经历这些坐标系的变化 ？

- 一个顶点从自身的物体空间出发，依次被变换到世界空间、观察空间、裁剪空间中
- 并不一定需要进行这些计算, 可以在 cpu 端对这些变换矩阵进行预计算, 最后直接使用一个单独的变换矩阵来将顶点变换到目标空间中即可。

## 片元着色器的作用？什么样的内容写在片元着色器里？

片元着色器也叫做像素着色器，其作为和功能主要有：
1. 指定数据插值类型
2. 执行纹理采样
3. 进行着色（光照）计算
4. 丢弃某些片元
5. 改变深度值
6. 将结果输出到一个渲染目标中

## 片元是什么, 和像素有什么不同?

- 像素只包含颜色信息
- 片元可能包含很多材质, 法线等信息
- [[片元]]并不等同像素, 可以说是潜在的像素. 多个片元再经过各种测试，完成着色计算之后，才可能会将信息输出到一个像素中。

## 什么时候在顶点做光照？什么时候在片元做光照？逐顶点光照和逐片元光照的区别？

- 在绝大部分实现中，大部分的着色计算都是逐片元执行的。
- 当设计一个着色实现的时候，我们需要评估它的计算频率（frequency of evaluation）
    - 顶点着色器（Vertex Shader）——在每个曲面细分前的顶点上进行计算。
    - 壳着色器（Hull Shader）——在每个表面面片上进行计算。
    - 域着色器（Domain shader）——在每个曲面细分后的顶点上进行计算。
    - 几何着色器（Geometry shader）——在每个图元上进行计算。
    - 像素着色器（Pixel shader）——在每个片元上进行计算。
- 如果一个模型的顶点密度很高，那么逐顶点的着色和逐片元的着色结果差别很小；如果一个模型的顶点很稀疏，那么顶点着色会导致着色错误。
- 这些错误的原因是由于着色方程中的一部分项（尤其是高光部分），在网格表面上具有非线性变化的值。这使得它们并不适合在顶点着色器中进行实现，因为顶点着色器的计算结果，会在光栅化阶段被线性插值，然后再输入到像素着色器中。
- 原则上来说，我们可以在像素着色器中只计算着色模型的高光（specular highlight）部分，并在顶点着色器中计算着色模型的剩余部分，这样应该就不会产生视觉瑕疵了，而且在理论上会节省一些计算量。但是在实践中，这种混合的实现方式往往并不是最优选择。首先，着色模型线性变化的部分往往是计算成本最小的部分，并且以这种方式将计算过程分离开来，也会带来额外的性能开销，例如重复的计算和额外的可变输入等，从而导致弊大于利。

## 光照计算发生在哪个shader里？

- 大部分的着色计算都发生在像素着色器中。

## 顶点着色器和像素着色器的输入输出分别是？像素着色器的输出除了颜色还有什么？

- 顶点着色器
    - 输入: 顶点 Vertex, 包括位置, 法线, uv, 等, 各种常量数据, 所需的 MVP 矩阵等等
    - 输出: 变换后的顶点位置和材质参数
- 像素着色器:
    - 输入
        - 插值后的 uv, 法线, 颜色等. 
        - [[SV_POSITION]] 屏幕空间像素中心坐标
        - 梯度信息
        - 三角形可见性信息
    - 输出:
        - 片元的颜色值
        - 深度测试的深度值，用于替换原本的片元深度。

## 除了 fs、vs 还有哪些着色器？它们的作用？写代码时用过哪些着色器？说一下几何着色器？

- [[Compute Shader]]
    - 使用 Compute shader 进行了 Tile based lighting, 将屏幕空间以 16\*16 分 tile, 记录每影响每个 tile 内的点光源信息
- [[几何着色器]]
    - 在学习 vulkan 时见到使用几何着色器实现 Spot Light 的阴影的做法, 简单来讲就是对于同一个世界空间的三角形, 使用三个不同的投影矩阵生成三个不同三角形, 光栅化器会将这几三角形绘制到阴影贴图数组的不同层中，并自动写入深度。
- 曲面细分阶段中的
    - [[壳着色器|Hull Shader]]
    - [[域着色器|Domain Shader]]
    - [[曲面细分器|tessellator]]
    - 简单来说, 壳着色器决定细分程度，曲面细分器生成点阵拓扑，域着色器则计算出这些新顶点的最终三维位置和属性。

## 顶点着色器和片元着色器性能比较？

- 顶点着色器是逐顶点调用的，像素着色器是逐片元调用的，二者具有不同的计算频率，一般来说，游戏中的片元着色器调用次数要远远多于顶点着色器。在分配计算任务的时候，需要考虑该任务的计算频率。
- 如果顶点着色器在实现某些计算功能的时候，不会产生瑕疵，那么则可以将这个任务放入顶点着色器中进行执行，因为它的执行频率要低得多。

## 如何在shader中传入数据

- 除了各个着色器本身的常规输入数据之外（Vertex Buffer），**vulkan 中**还可以使用以下方式：
    - Uniform Buffer (dx 和 hlsl 中叫Cbuffer) 用于传递少量、更新频率较低的数据（例如，每帧更新的相机矩阵）。
    - Storage Buffer (Rwbuffer) 用于传递大量、任意格式的数据，并支持读写（例如，粒子系统、GPU 计算）。
    - 纹理 Images: 提供所需的纹理
    - Push Constants (推送常量) 用于传递极少量、更新频率**极高**的数据（例如，每个绘制调用都不同的物体索引, Model 矩阵等）。
    - **Specialization Constants (特化常量)** 在创建渲染管线时“烘焙”到到着色器中的常量。vulkan可以根据特化常量优化掉不必要的分支. 可以使用特化常量生成很多的着色器变体, 避免手动编写大量着色器变体

## shader是什么，一般控制什么数据？

- shader是着色器，是段能够被GPU执行的程序。
- 基础的数据是fp32，fp64，int32等，以及在此基础上扩展出的向量和矩阵。

## 法线贴图是在顶点着色器还是片元着色器中计算使用？

- 法线贴图在像素着色器中进行采样，然后用于光照计算。
- **原因**
    - 如果在顶点着色器中采样，我们最多只能得到三个顶点上的法线，然后在三角形内部进行插值，这就完全失去了法线贴图“提供像素级细节”的意义，退化成了普通的逐顶点光照。
- 使用 [[TBN]] 矩阵将法线从切线空间转换到世界空间

## 了解compute Shader吗 ？

利用GPU进行并行计算的一种着色器，它是一种特殊的着色器，并没有锁定在图形管线中的固定位置。例如用于毛发渲染，剔除等可以并行化的计算密集操作。
[[Compute Shader]]

## Compute shader的优缺点？

[[Compute Shader#得失]]

## Compute Shader 剔除结果需要回读到 Cpu 吗？能直接绘制吗？

不需要回读，compute shader可以直接发起绘制命令。

## 有用 Compute Shader 实现过什么功能？

常见的功能包括：

1. 剔除算法
2. 光源分类
3. 粒子系统
4. 一些后处理效果（模糊等）
5. 一些计算密集型任务（鱼群算法）

[[TileBasedLighting]] #渲染器实现细节 
使用 Compute shader 进行了 Tile based lighting, 将屏幕空间以 16\*16 分 tile, 记录每影响每个 tile 内的点光源信息

## Compute Shader 使用时会有什么问题，需要注意什么？

1. 注意dispatch和numthreads的分配。
2. 尽量避免使用分支和循环。
3. 并不适所有的效果都适合compute shader执行，尤其是涉及传统像素绘制的任务，可能不一定有像素着色器快。
4. 注意compute shader在不同平台的兼容性和实现方式。

## 有一个设计好的一个渲染算法，但效率较低，如何最快地分析出vs和fs哪个对效率影响最大？

- 问题的核心是如何修改顶点着色器和像素着色器的执行比例。
- 可以直接降低游戏画面的分辨率，观察游戏游戏帧率的变化。
    - 如果游戏帧率大幅上升，说明像素着色器对效率的影响较大；
    - 如果游戏帧率上升有限，说明顶点着色器对效率的影响较大。

## 如何优化shader代码？

- 首先需要了解 GPU shader 上哪些操作, 指令开销大
    - 内存访问与纹理操作, 几十几百的时钟周期
    - if  else 分支. GPU 就需要串行执行所有走过的路径，大量计算单元处于闲置状态。
    - 复杂的数学函数 (没有专门硬件支持加速)
        - **三角函数**: `sin`, `cos`, `tan`, `asin`, `acos`, `atan`。
        - **指数与对数**: `pow`, `exp`, `log`, `log2`。
    - discard, 修改深度 (这会禁用 early-Z)
    
常用的着色器包括顶点着色器和像素着色器，下面是针对shader代码本身的一些优化，不涉及如何减少着色器调用等方面。
1. 对于会在每个顶点都进行的计算，可以提取出来，在CPU端完成，然后在顶点着色器中直接使用，例如各种变换矩阵。
2. 尽量使用着色语言的内置函数。
3. 使用代数方法来简化计算。
4. 对于一些简单且重复性较低的计算，避免函数封装。
5. 使用合适的精度。利用半精度
6. 使用内置函数来避免分支操作，尽量减少分支操作。
7. 像素着色器中尽量避免纹理采样操作。
8. 使用一些优化指令，例如循环展开（unroll）等。

## Vs 开销很大怎么办？

- 降低输入到顶点着色器中的数据量，即使用高效的三角形网格存储方式、简化模型、顶点数据压缩。
- 使用一些遮挡剔除方法，避免将图元输入到管线中。
- 将顶点计算的公共部分提取出来，在CPU中进行，并作为常量传递给顶点着色器，例如各种变换矩阵。
- 对于静态物体的逐顶点光照，可以将光照信息烘焙为顶点的颜色。

## Fs 开销很大怎么办？

核心思路是两个：
- 减少过度绘制现象（即减少像素着色器的调用)
- 提高像素着色器本身的效率。

1. 避免使用较小尺寸的三角形，或者将这些三角形剔除，从而减少四边形过度绘制，以及提高线程占用率。
2. 尽量避免丢弃片元或者修改片元深度的操作，即开启early-z。
3. 减少采样纹理的操作。
4. 减少分支、循环操作。
5. 使用遮挡剔除算法, 如 [[Hi-Z]] [[Z-Prepass]]

## Shader的debug?

1. 使用一些分析工具，例如renderDoc。
2. 将shader中间结果作为颜色输出到屏幕上。

## GPU中分支语句（if）是怎么做的？

假设现在我们的着色器程序中遇到了一个“if”语句，
- 如果所有的线程都进入了相同的分支，那么这个warp可以不用管其他的分支，继续执行进入的那个分支即可。
- 但是，如果有几个线程，甚至是只有一个线程进入了其他的分支，那么这个warp 的所有线程就必须把两个分支都执行一遍，然后再根据每个线程的具体情况，丢弃不需要的结果。
- **这会使大量计算单元处于闲置状态**

## 什么情况下fs的执行次数会小于vs的执行次数？

顶点着色器逐顶点执行，其数量由模型顶点决定；
像素着色器逐片元执行，其数量由生成的片元执行。
- 当模型中的顶点数量很多，但是只覆盖了屏幕上的很少像素时（即生成的片元数量很少），像素着色器的执行次数会小于顶点着色器的执行次数。
    - 这种情况可以使用 LOD 进行优化
    - 如 [[Nanite]]
