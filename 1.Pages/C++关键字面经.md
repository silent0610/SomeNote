---
Type:
aliases: 
tags: 
modifiedDate: 2025/06/18, 20:17:36
---

# C++关键字面经

- static关键字的作用？
    - [[C++static]]
- const关键字的作用？
    - [[C++const]]
- constexpr 的作用
    - [[C++ constexpr]]
    - C++11 引入的新特性.constexpr 所修饰的必须是编译期可知的值. 用于修饰变量或函数, 将一些计算从运行时移到编译期, 从而加速.
    - 提高性能: 如果一个计算可以在编译期, 那么运行时只需要调用这个常量值即可, 提高了性能
    - 定义真正的常量: 各种数组, 枚举值, 静态断言等
    - 帮助分支优化: 可以在编译期确定哪条 if 分支, 另一条分支不被编译
- const和define的区别？
    - `const` 和 `#define` 在 C++ 中都可以用来定义“常量”，但**本质完全不同**
    - define 本质上是预处理宏. 被预处理器处理, 没有类型, 没有类型检查, 做的仅仅是遇到宏定义就行字符串的展开, 遇到多少次就展开多少次. 只在翻译单元中生效.容易有宏污染. 
        - define 只是展开, 不占用内存, 但是从汇编角度来说, define 以立即数的方式保留了多份数据的拷贝
    - const 在编译期进行, const 有类型, 有类型检查, 程序运行时为 const 分配内存. const 常量出现的地方是真正数据的内存地址. 只保留一份数据. 省去了不必要的内存空间. 有时编译器并不会为普通的 const 常量分配内存, 而是直接将 const 常量添加到符号表中，省去了读取和写入内存的操作，效率更⾼。
    - 作用阶段
        - define 在预处理阶段
        - const 在编译期起作用
    - 安全性
        - define 只做文本替换, 不进行类型检查, 可能存在窄化
        - const 类型检查
    - 内存占用
        - define 保留多分数据拷贝
        - const 在内存中只有一份
- inline与宏的区别?
    - 宏定义：预处理阶段进行文本替换
    - inline 函数：在编译阶段进行插入展开
    - inline 函数有类型检查，相比宏定义比较安全；因为inline函数的参数具有类型检查和作用域，在编译阶段会进行错误检查，可以发现语法错误和类型错误。
- inline函数与普通函数的区别？
    - 函数需要进行调用，这个调用过程有一定的开销。标记为inline的函数，在函数调用的地方会进行展开，而不是进行函数调用，节省函数调用所带来的参数传递、栈空间的进栈与出栈等开销，从而提高执行速度。
        - 但相应的, 多次展开会使代码文件变大.
        - 所以, inline机制适用于优化规模较小、流程直接、频繁调用的函数；并且它只是一个向编译器的**请求**，编译器可以选择忽略这个请求，一个函数具体会不会被展开，取决于编译器的实现。
- extern关键字的作用？
    - extern关键字：用于声明外部变量或者外部函数，表示该变量或函数在其他文件中定义。（此函数/变量是在别处定义的，要在这里进行引用）。通过extern声明，可以在当前文件中引用其他文件中定义的变量或函数。
    - 

        ```cpp
        // File1.cpp
        int globalVariable = 10; // 外部变量
        // File2.cpp
        extern int globalVariable; // 外部变量的声明
        int main() {
            cout << "Global variable: " << globalVariable << endl;
            return 0;
        }
        ```

    - 在 C++ 中 extern 还有另外⼀种作用，用于指示 C 或者 C++函数的调用规范。比如在 C++中调用 C 库函数，就需要在 C＋＋ 程序中用 extern “C” 声明要引用的函数。这是给链接器用的，告诉链接器在链接的时候用C 函数规范来链接。主要原因是 C＋＋ 和 C 程序编译完成后在目标代码中命名规则不同，用此来解决名字匹配的问题。
- volatile关键字的作用？
    - [[C++volatile]]
- explicit关键字的作用？
    - **只用于修饰类的构造函数**，不能进行隐式转换，只能以显式的方式进行类型转换。
    - 一般来说，当一个构造函数只有一个简单参数的时候，需要使用explicit进行修饰，防止发生隐式转换。
- sizeof和strlen的区别？
    - sizeof是运算符，在编译期完成；strlen是处理字符的库函数
    - sizeof的参数可以是任何类型；strlen的参数必须是字符指针，并且需要以\0结尾的字符
    - strlen 的返回值不包含 `\0`
