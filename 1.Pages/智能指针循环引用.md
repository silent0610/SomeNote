---
Type:
  - Page
aliases: 
tags: 
modifiedDate: 2025/06/16, 19:26:32
---

# 智能指针循环引用

- 当两个或多个对象通过 `shared_ptr` 相互指向，形成一个闭环时，它们的强引用计数可能永远无法降到 0，即使这些对象在逻辑上已经不再被外部使用。这会导致内存泄漏。

就是说:
- 当 A 存有指向 B 的智能指针
- 且 B 存有指向 A 的智能指针时
- 两者循环引用, 永远无法被销毁, 从而造成内存泄露

## 解决

### 使用weak_ptr

通常使用 [weak\_ptr](weak_ptr.md) 解决循环引用
将循环引用中的**一方**（通常是“从属”关系的一方，例如子节点引用父节点，或在双向链表中其中一个方向）的 `shared_ptr` 改为 `weak_ptr`。

### shared_ptr.reset()

即手动释放一个指针,从而打破闭环
`shared_ptr.reset()` 是用来**释放当前所管理的对象**，并将 `shared_ptr` 置为空（即不再拥有任何资源）。
- **减少引用计数**：
    - `reset()` 会把当前对象的引用计数减 1；
- **若引用计数变为 0**：
    - 对象立即被析构、资源被释放；
- **自身变为空 `nullptr`**：
    - 相当于 `ptr.use_count() == 0`；
    - `ptr.get() == nullptr`；
    - 可重新 `reset(new T(...))` 设置新对象。
