---
Type: 
aliases:
  - 普里姆算法
tags: 
modifiedDate: 2025/06/10, 18:47:37
---

# 普里姆算法

**寻找加权连通图的**最小生成树

## 步骤

1. **初始化：**
    - 选择图中的任意一个顶点作为起始顶点，将其加入到最小生成树的顶点集合 `U` 中。
    - 初始化一个空的边集合 `E_mst`，用于存储最小生成树的边。
    - 维护一个数组或优先队列，记录每个“尚未在树中的顶点”到“已在树中的顶点集合”的最短连接边（及其权值）。
2. **迭代构建：**
    - 重复以下步骤，直到最小生成树包含图中所有顶点（即 `U` 包含所有顶点）：
        - 从所有连接 `U` 中顶点和 `V \ U`（`V` 是图中所有顶点集合）中顶点的边中，选择一条权值最小的边 `(u, v)`，其中 `u` 属于 `U`，`v` 属于 `V \ U`。
        - 将选定的边 `(u, v)` 添加到 `E_mst` 中。
        - 将顶点 `v` 添加到 `U` 中。
        - **更新：** 对于新加入 `U` 的顶点 `v`，检查所有与 `v` 相连的、且另一端点仍处于 `V \ U` 中的边。如果通过 `v` 连接到 `V \ U` 中某个顶点 `w` 的权值比之前已知的最短连接边更小，则更新 `w` 的最短连接信息。

### 示例

假设有一个图，顶点为 A, B, C, D，边及其权值为： (A,B,4), (A,C,2), (B,C,1), (B,D,5), (C,D,3)

我们用Prim算法找它的最小生成树：

1. **选择 A 作为起始点。**
    
    - `U = {A}`
    - `E_mst = {}`
2. **迭代：**
    
    - **当前已在树中的顶点：A**
    - 从 `A` 出发的边：(A,B,4), (A,C,2)
    - 选择权值最小的边：(A,C,2)
    - 将 `C` 加入 `U`。
    - `U = {A, C}`
    - `E_mst = {(A,C)}`
3. **迭代：**
    
    - **当前已在树中的顶点：A, C**
    - 从 `U` 出发到 `V \ U` (即 B, D) 的边：
        - (A,B,4)
        - (C,B,1)
        - (C,D,3)
    - 选择权值最小的边：(C,B,1)
    - 将 `B` 加入 `U`。
    - `U = {A, C, B}`
    - `E_mst = {(A,C), (C,B)}`
4. **迭代：**
    
    - **当前已在树中的顶点：A, C, B**
    - 从 `U` 出发到 `V \ U` (即 D) 的边：
        - (B,D,5)
        - (C,D,3)
    - 选择权值最小的边：(C,D,3)
    - 将 `D` 加入 `U`。
    - `U = {A, C, B, D}`
    - `E_mst = {(A,C), (C,B), (C,D)}`
5. 所有顶点都已加入 `U`，算法结束。
