---
Type:
aliases: 
tags: 
modifiedDate: 2025/06/17, 11:12:49
---

# 右值引用与移动语义

[[左值与右值]]

## 右值引用

一个类型为 `T` 的右值引用的语法是 `T&&`
右值引用只能绑定到右值。

```cpp
int x = 0; // `x` 是类型为 `int` 的左值
int& xl = x; // `xl` 是类型为 `int&` 的左值
int&& xr = x; // 编译错误 -- `x` 是左值
int&& xr2 = 0; // `xr2` 是类型为 `int&&` 的左值 -- 绑定到右值临时量 `0`

void f(int& x) {}
void f(int&& x) {}

f(x);  // 调用 f(int&)
f(xl); // 调用 f(int&)
f(3);  // 调用 f(int&&)
f(std::move(x)); // 调用 f(int&&)

f(xr2);           // 调用 f(int&)
f(std::move(xr2)); // 调用 f(int&& x)
```

## 移动语义

C++11引入的一种特性，它允许对象的资源（如堆内存）在移动操作中被转移而不是复制，从而提高性能。移动语义通过*右值引用*来实现。

移动一个对象意味着将它所管理的某些资源的所有权转移到另一个对象

移动语义的第一个好处是性能优化。当一个对象即将结束生命周期时，无论是因为它是一个临时对象，还是通过显式调用 `std::move`，移动通常是转移资源的更便宜的方式。例如，移动一个 `std::vector` 只是将一些指针和内部状态复制到新向量中——复制则需要复制向量中的每个元素，这是昂贵且不必要的，尤其是当旧向量即将被销毁时。

移动语义还使得像 `std::unique_ptr`（[智能指针](https://chengxumiaodaren.com/docs/cpp-new-feature/cpp-11/#%e6%99%ba%e8%83%bd%e6%8c%87%e9%92%88)）这样的不可拷贝类型能够在语言级别保证一次只有一个实例管理资源，同时能够在作用域之间转移实例。

### [[C++Move|std::move]]
