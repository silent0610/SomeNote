---
Type:
aliases: 
tags: 
modifiedDate: 2025/06/25, 14:04:03
---

# 阴影算法面经

## 知道 CSM 吗？CSM 存在什么问题？如何优化 CSM 的性能？CSM的改进方法?

-  [[级联阴影贴图|CSM]] 级联阴影贴图, 其核心思路是沿着观察方向, 将视锥体划分为若干个区域, 一般是四个. 每个区域使用不同分辨率的阴影贴图, 越近的分辨率越高. 这样可以为距离观察者较近的, 也就是更为重要的表面, 提供更多的样本. 从而缓解瑕疵. 划分方法一般是均匀划分和对数划分[^1]

## 如何解决改变主相机的FOV时CSM的阴影抖动问题？

当相机移动时, 阴影会发生抖动, 其原因在于: 当相机发生移动的时候, 光源的投影矩阵每帧会重新生成, 会导致生成的阴影贴图有微小的差别. 在相机发生移动时, 阴影边缘的像素会不断进出阴影范围, 从而造成抖动

**强制对齐**
对于方向光而言，对应的解决方案是对每个后续生成的阴影贴图进行限制，使得它们在世界空间中保持相同的相对纹素位置。也就是说，你可以将阴影贴图视为在整个世界上强加上一个二维网格的参考网格，每个网格单元都代表了阴影贴图上的一个像素样本。当你在场景中移动时，阴影贴图会为这些相同的网格单元生成不同的样本集合。换句话说，光源的视图投影矩阵会被限制到这个网格中，从而保持帧与帧之间的一致性。
- 怎么对齐?
    - 世界空间纹素大小 = 级联的世界空间尺寸 / 阴影贴图的分辨率
    - 将理论的级联视锥体中心点坐标 `(x, y, z)` 变换到光源的观察空间。
    - 将其 `x, y` 坐标除以“世界空间纹素大小”，然后取整（`floor` 或 `round`）。
    - 再将取整后的结果乘以“世界空间纹素大小”。
    - 这样就得到了一个“对齐”后的新坐标。它被“吸附”到了最近的网格点上。
    - 用这个**“对齐”后的坐标**去更新“理论矩阵”，得到一个最终的、**“稳定矩阵”**。

使用2^n次方的阴影贴图，并使得光源相机的视口为一个正方形。

## One Pass的结果怎么和two pass对应的？着色点是怎么对应到 ShadowMap 上的？如何用深度纹理与实际shading point形成映射？

指 shadow map 技术的两 pass 原理
- 在第一个 pass 中, 从光源视角生成 shadowmap, 并保存使用的 MVP 矩阵
- 在第二个 pass 中, 我们正式渲染场景, 对于一个着色点, 利用逆矩阵得到世界空间坐标, 或者直接使用保存的世界空间坐标, 乘光源的 MVP 矩阵, 得到点 p 在光源视角下的位置和深度, 再采样 shadowmap 对应位置的深度值, 进行比较

## 你写了shadowmap，说说原理？shadow map实现？缺点？有哪些改进？

[[Shadow Map]]
shadow map 的核心思想是从光源视角出发, 使用 z-buffer 保存整个场景的深度值, 然后在生成阴影. 能够被光源看见的任何物体都会被照亮, 看不见的物体则都处于物体中. 
具体的, shadow map 是一个两 pass 算法
- 在第一个 pass 中, 从光源视角生成 shadowmap, 并保存使用的 MVP 矩阵
- 在第二个 pass 中, 我们正式渲染场景, 对于一个着色点, 利用逆矩阵得到世界空间坐标, 或者直接使用保存的世界空间坐标, 乘光源的 MVP 矩阵, 得到点 p 在光源视角下的位置和深度, 再采样 shadowmap 对应位置的深度值, 进行比较, 从而判断是否处于阴影中

### 缺点和改进方法

- 阴影痤疮（shadow acne）[[自阴影和阴影偏移]]
    - 原因
        - 阴影贴图的分辨率和z-buffer的数值精度有限
    - 改进方法, 各种偏移算法
        - 固定偏移
        - 坡度修正的偏移（slope scale bias）
        - 法线偏移偏差（normal offset bias）等
        - 或者是只渲染物体的背面或中间, 叫做第二深度阴影映射![[assets/20230611111703.png]]
    - 但是过大的偏移会导致漏光和 [[Peter Panning]] 问题
- 单纯的shadow map只能生成硬阴影
    - 改进方法 
        - [[PCF]]
        - [[PCSS]]
- 理想情况下, 我们希望阴影贴图中的一个纹素和平门像素一一对应, 但往往做不到, 这就会出现 
    - **透视走样** 
        - 指阴影贴图中的每个纹素都对应了大量的前景像素, 
        - **近处物体占据屏幕空间较大，但在阴影贴图中占据的空间很小**。
        - 导致近处阴影非常模糊甚至断裂，因为纹素不足。
        - 光源视角下的投影分布与摄像机观察空间不匹配，近处细节被浪费。
    - **投影走样**
        - 当表面与光线平行的时候，单个纹素也会覆盖多个像素。
        - 当阴影落在与光线**接近平行的表面**上（如地面），单个阴影贴图纹素会**被拉长**，覆盖多个像素。
        - 导致阴影边缘呈现严重锯齿，难以消除。
    - 通过使用 CSM 解决
        - 近距离的物体获得更高分辨率的阴影贴图
        - 远处的物体分配到的阴影贴图分辨率较低

## PCF、PCSS原理？PCF，PCSS等具体实现？软阴影怎么做？

PCF 和 PCSS 是对阴影贴图的扩展, 其目的是实现伪软阴影. 
[[PCF]]
[[PCSS]] 旨在解决 PCF 的固定半影大小问题, 试图通过对阴影贴图上的附近区域进行搜索，来找到所有可能的遮挡物。使用这些遮挡物与表面位置的平均距离决定 PCF 采样区域的宽度。

## 阴影的实现？实时渲染的阴影算法？阴影怎么做？

- 实时阴影算法
    - 阴影体算法（shadow volume）：提供了一个精确的、解析的解决方案，光源与表面的相互作用会生成一组三角形，它可以定义任何给定位置是被光源照亮的还是位于阴影区域中。其缺陷在于不可预测，不稳定的计算成本，因此目前没有使用。
        - 每个遮挡三角形生成一个阴影体 ![[assets/20230611111459.png]]
        - 每当光线穿过了阴影体的正面（即面向观察者的一面）时，我们就让计数器加1；
        - 每当光线穿过截断金字塔的背面时，我们便将相同的计数器减1
        - 光线击中了场景中的物体。此时，如果计数器大于0，则说明该像素位于阴影中；否则就不在阴影中。![[assets/20230611111518.png]]
    - 阴影贴图, 使用 PCF 或 PCSS 获得软阴影效果, 以及 CSM
    - 自适应体积阴影贴图, 通过在三维体积中构建分辨率可变的体素网格，以记录光照遮蔽信息，从而实现在不同区域以不同精度生成真实感体积阴影。
    - 光追阴影：从阴影接收物的表面位置出发，向光源发射一条射线，如果有物体阻挡了光线，则说明该表面位置位于阴影中。 **物理正确但实时渲染中做不到**
    - 不规则 Z-buffer（Irregular Z-buffer, IZB）
        - 问题
            - **计算和存储开销大**，特别是在实时渲染中难以高效实现
            - 在现代 GPU 上不易并行化（因为不规则采样结构）
        - 流程
            - **相机视角下收集可见点**  
                渲染场景，获取相机可见表面的深度和位置。
            - **转换至光源空间 & 构建光源视锥**  
                将这些可见点变换到光源空间，并据此构建一个紧致的光源视锥体。
            - **构建 IZB（Irregular Z-buffer）结构**  
                将每个点插入到其对应的光源空间纹素中，形成每个纹素下的“待测点列表”。
            - **使用保守光栅化渲染遮挡物**  
                将所有可能的遮挡三角形使用保守光栅化方式光栅化到 IZB，确保不漏掉任何可能遮挡点。
            - **像素着色器中进行可见性测试（截锥体追踪）**  
                对 IZB 中每个点执行从点到光源的可见性测试（判断是否被遮挡），并将结果用于最终阴影渲染。

## 平行光阴影怎么做？点光源阴影怎么做？

平行光使用一个正交投影的相机来渲染shadow map，该相机的观察方向与平行光方向一致。由于平行光一般是场景中的主要光源，因此可以使用CSM。
- 光源相机位置一般通过构建视锥体包围盒确定

点光源使用一个透视投影的相机，对点光源AABB的六个面分别渲染shadow map。cubemap

## 屏幕空间阴影级联阴影了解过吗?

指的就是常规的CSM，只是在屏幕空间中进行深度比较。
大意是先用一个 pass 拿到屏幕空间的深度图, 用深度重建出世界空间坐标再到光源空间和 shadowmap 比较
**和延迟渲染结合的很好**

[^1]: 我的渲染器中实现为对数划分和均匀划分的加权 #渲染器实现细节  
