---
Type:
aliases: 
tags: 
modifiedDate: 2025/07/09, 16:11:39
---

# 性能优化面经

## 如何测试渲染流程中的瓶颈？如果游戏性能出现问题，怎么考虑问题？

- 性能瓶颈可以理解为管线中, 由于某个部分的负载过重或性能不足, 导致整个管线性能显著下降.
- 要想解决瓶颈, 首先就得定位瓶颈的位置, 确定是渲染管线的哪个阶段出了问题. 定位的方法是对针对各个阶段进行测试
- 渲染管线可以粗略分为四个阶段, 即应用阶段, 几何处理阶段, 光栅化阶段和像素处理阶段
    - 对于应用阶段
        - 降分辩率测试, 如果 FPS 基本不变, 说明很可能瓶颈在 CPU 端. 或顶点着色器相关
        - 查看 CPU 占用率, 是否为 100%
        - 直接降低 CPU 频率, 如果 CPU 频率的降低和程序性能降低成强相关, 则 CPU 很可能 是瓶颈
        - 使用一个空的驱动程序，不向GPU发送工作任务。
    - 对于几何处理阶段 (较难测试, 因为会直接导致其他阶段的工作量发生变化)
        - 使用 LOD, 或直接增大顶点数据, 从而确定瓶颈是否来自模型数据传输.
        - 让顶点着色器变得更长更复杂, 或者更简单, 判断是否顶点着色器瓶颈
    - 光栅化阶段
        - 增大顶点着色器和像素着色器复杂程度, 延长执行时间, 如果渲染时间相对稳定, 则说明问题可能出在光栅化阶段
        - 大量的小三角形可能会导致光栅化阶段出现瓶颈, 理由和 [[Nanite]] 的软件光栅化相同, 光栅化是逐 tile 的, 对于小三角形, 比如只占一个像素的三角形, 存在大量浪费
    - 像素处理阶段
        - 改变屏幕分辨率
        - 修改着色器的复杂程度, 根据影响大小, 判断瓶颈
        - 修改帧缓冲的输出 bit 位数, 改变带宽成本, 来查看合并阶段是否存在瓶颈

## 简要介绍各种剔除方法与原理？

- **剔除**是计算机图形学中一系列性能优化技术的总称。其核心思想是，在将物体送入渲染管线的后续阶段之前，预先识别并“剔除”掉那些最终对画面没有任何贡献的物体或图元（如三角形）。通过剔除，可以极大地减少CPU和GPU的负载，从而显著提升渲染性能。
- 视锥剔除
    - 位于视锥外的物体是看不见的, 发生在应用程序阶段
    - 一般会对物体构造 BV, 与视锥体进行相交测试 那些不与视锥体相交且在视锥外的物体不会被渲染
- 遮挡剔除
    - 被其他不透明物体遮挡的物体是看不见的
    - 方法
        - 深度缓冲, 深度测试
            - 包括 [[Hi-Z]] , [[Z-Prepass]], 深度重投影, 预先排序等技术
        - 软光栅化: 提前对几个大型物体进行光栅化并写入深度, 获得一个大致的深度缓冲, 然后使用这个深度缓冲来对物体进行剔除
        - 遮挡查询, 向 GPU 发送指令, 获得某个模型通过深度测试的样本数量, 样本数量为 0, 则说明这个物体被完全遮挡
        - 预计算 PVS, 在场景中的一些区域中, 预计算哪些物体是可见的, 然后将可见性信息保存下来, 当玩家来到某个区域是, 直接可以获得哪些物体是可见的, 然后渲染即可
- [[入口剔除]]
    - 在室内场景中，通过门、窗等portal，我们只能看到一部分物体，其他物体是看不见的。可以看成是视锥剔除的变种。
    - 根据此时的相机位置, 门窗信息, 构建一个视锥体, 对于位于门窗对面的物体, 如果其 BV 和这个视锥体不相交, 且在视锥体之外, 说明这个物体通过这个 portal 是不可见的. 
- 背面剔除
    - 背面的三角形是看不见的
    - 在 vulkan 中, 可以通过 CULL_MODE_BACK, 进行设置. 可以在很多阶段进行
        - 例如, 在观察空间中, 计算三角形的朝向, 与观察方向进行点乘
        - 在裁剪空间中 (实践), 利用 cross 计算三角形法线方向.
- 细节剔除和小三角剔除
    - 某些较小的细节物体和细节三角形对于画面的最终贡献是有限的，可能并不会占据任何像素。
    - 光栅化时计算三角形在屏幕空间占据的面积，如果面积过小，则不渲染这个三角形。

## 如何在CPU端减少draw call？

- Batch 合批 : 将多个**有相同材质的**物体合并到一个 mesh 中，这样就只需要一次draw call来渲染该集合。
    - 静态
        - 对于场景中**不会移动、旋转或缩放的静态物体**（例如，建筑、不会动的岩石、固定的装饰品），引擎可以在游戏运行前（或关卡加载时）将它们的网格（Mesh）合并成一个或几个大的网格。**前提是这些物体共享相同的材质**。
    - 动态
        - 引擎在**每一帧**都会自动尝试将那些**正在移动的小物体**进行批处理。它会找到共享相同材质的、且顶点数量很少的物体，在 CPU 上将它们的顶点数据进行转换和合并，然后发送给 GPU。
- GPU instancing 实例化 在一次draw call中，对同一个对象进行多次绘制。（比如要绘制大量的灌木丛树木）
- Culling  将不需要渲染的物体剔除，减少过度绘制。

## 是否在CPU端的项目中做过访存优化？

- 存储访问的性能增长相比于算力的增长, 增长的优先. 因此内存访问模式会极大影响查询性能. 有以下方法和准则可以帮助优化访存
    - 目标: **让每一次从主内存加载到缓存行的数据，都尽可能地被接下来的计算所用到，从而最大化缓存命中率。**
    - 代码中按照内存顺序来访问数据
    - 在代码关键部分, 避免使用跳转, 函数调用和间接指针
    - 将数据结构与内存对齐, 可以使用一些 padding 操作 [[C++内存对齐]]
    - 不同的数据组织方式在不同架构上的性能表现也不同，对项目中的数据结构进行重新组织并实际测试。
    - 使用一些内存池技术, 减少内存的分配与释放
    - 避免在渲染循环中进行分配或者释放内存操作，即在一次渲染开始之前分配内存，在一次渲染结束之后释放内存。
    - 数据分段处理。如粒子包含速度、密度、位置多个属性，不用结构体，用多个buffer。
        - [[ECS]]? 面向数据编程?

```cpp
// 结构体
struct Particle {
    float position[3]; // 12 bytes
    float velocity[3]; // 12 bytes
    float density;     // 4 bytes
    // ... 其他属性
};
Particle particles[1000];


// 分段
float positions[1000][3]; 
float velocities[1000][3]; 
float densities[1000];
```

## 了解过UI的合批吗？

- UI 的合批是指使用一次 [[Draw Call]] , 来渲染多个满足特定条件的UI元素UI. 优化方法有
    - 保持 UI 的 层级一致. 注意 UI 的遮挡关系（避免相互遮挡打断合批）
        - 当引擎遇到第一个图片时，它会准备一个批次。接着检查第二个、第三个……如果这些图片都使用相同的材质和图集，引擎就会把它们全部塞进这个批次里。
        - 如果在两个使用相同图集的图片之间，夹了一个使用不同材质的元素, 那么批次就会在这里被打断. 
    - 使用图集来打包 sprite。
        - 将UI中许多零散的小图片, 如图标, 按钮等,合并到一张大纹理图片上. 所有来自同一张图集的图片，虽然它们是不同的UI元素，但它们引用的都是同一张大纹理。因此，它们可以**共享同一个材质**。
    - 将静态UI与动态UI设置不同的Canvas。
        - 当一个Canvas中的**任何一个**UI元素发生变化（位置、颜色、内容等），整个Canvas都需要进行**“重建”（Rebuild）**。重建是一个CPU密集型操作，它会重新计算Canvas内所有UI元素的顶点数据等信息。
    - UI层级不要太多太深。
        - 这主要不是为了减少Draw Call，而是为了**降低Canvas重建时的CPU计算量**。当Canvas需要重建时，它需要遍历整个UI层级树，计算每个元素的最终位置、旋转、缩放和顶点数据。层级越深、越复杂，这个遍历和计算的过程就越耗时。保持一个相对扁平化的层级结构可以加快这个过程。
    - 使用单独的UI相机来渲染UI。
        - 渲染分离, 管线更有条理
        - clear flags 控制. UI相机通常不需要清除深度缓冲
        - 后期效果隔离

## 移动端常见优化

### 顶点着色器

- 使用index draw call，无论顶点是否会被复用
- 不要使用32位的index buffer

### 像素着色器

- 尽量使用半精度, float16, 除了代表位置的 pos 或者 depth
- 不需要做 [[Z-Prepass|Pre-Z]], 因为移动端使用了 [[基于区块的延迟渲染器|Tile-Based Deferred Renderer]]渲染架构，会对绘制进行排序
- 避免使用 alpha blend, discard 等破坏 earlyz 的操作
- 不要通过uniform buffer来控制shader分支
    - Uniform Buffer 中的值只在运行时可知
    - 将“编译时”可以确定的信息，错误地推迟到了“运行时”才去决定，从而束缚了编译器优化的手脚。
    - 所以可以考虑使用特化常量替代
- 减少一次draw call的代码量（减少shader执行长度以及使用的寄存器数量，从而获得更好的占用率）
- 减少通用寄存器的使用
    - 两个vec2打包成一个vec4
    - 将短循环展开
- 使用 `LOAD_OP_CLEAR` 或者 `LOAD_OP_DONT_CARE`
    - 选择 `LOAD_OP_CLEAR` 是为了**渲染的正确性**（从一个已知的状态开始），而选择 `LOAD_OP_DONT_CARE` 是为了**极致的性能**（告诉驱动可以跳过不必要的工作）。

## shader中循环展开可以带来性能提升吗？为什么可以带来效率提升？

- 循环展开是指使用 `[unroll]` **关键字** 将for循环进行展开，具有以下优点和缺点：
    - 优点
        - 减少用于控制循环变量的相关指令. 循环的各种循环控制和初始化操作是需要花费额外指令的. 如果循环体本身指令较少, 那么循环的额外开销较大. 可以展开循环, 提高效率
        - **优化指令流水线**：如果没有进行循环展开, 那么在每次循环结束的时候，会判断是否退出循环, 并使用goto指令跳转到循环体开始的地方。展开循环后，会使得指令变得更加连续，更好的适应GPU的指令流水线，提高执行效率。
        - 编译器优化. 帮助编译器进行循环优化, 提高执行效率
    - 缺点
        - **指令膨胀**, 展开后的代码体积会显著增大。如果循环次数很多，生成的二进制代码会非常庞大。代码体积变大可能会导致无法完全装入高速的**指令缓存**中。如果发生**缓存未命中**（Cache Miss），处理器需要从速度慢得多的主内存去读取指令，这可能会完全抵消掉循环展开带来的好处，甚至导致性能下降。
        - **寄存器数量需求** 在循环展开之后，可能会需要更多数量的寄存器, 如果一个 Shader 使用了过多的寄存器，它会限制能够在一个 SM 上同时运行的线程束(Warp)的数量，从而导致 GPU 的计算单元占用率(Occupancy)降低。
    - 总结
        - 循环展开（如果能展开的话）在大部分情况下都可以优化执行效率。
        - 当循环指令过长，导致生成的指令数量和所需的寄存器数量过多，循环展开后会降低执行效率或 GPU 占用率. 

## 移动端和桌面端GPU寄存器数量差异？

- 寄存器数量直接决定了 shader 的复杂程度。桌面端的 shader 拿到移动端来跑，性能的下降并不是和指令数量成线性关系. 还会因为寄存器数量不足，导致可执行的 warp 数量变少. 甚至频繁出现缓存未命中, 读取慢得多的系统内存
- 5090 256KB 每 SM, SM 包含 4warp, 每个 warp32 cuda. 
- 怎么查看 shader 的寄存器占用?
    - 在使用 dxc 编译着色器时, 使用 `-Fc` 编译, 会输出包含详细统计信息的汇编代码。

## 资源、特效等如何进行性能优化

### 1. 资源分级

1. 美术资源分级：角色 玩家控制角色和NPC角色的规格有差异，考虑分 SABC级别
2. 母材质分级：给到SA级美术资源的母材质和BC级别的美术资源的母材质在功能上做区分和精简 保证性能池子划分的重点

### 2. 平台分级

- PC/移动/主机平台：不同的平台给与不同的资源分级规范，例如PC端的美术资源和材质资源级别和移动端要有所区分

### 3. 质量分级

- 高中低画质的QualitySwitch做区分，高画质全效果，中画质砍部分效果，低画质有东西能看到就行

### 4. 美术资源层面的优化

1. 模型：
    1. 多级别的LOD模型
    2. 规范限制PC和移动端Mesh的最大三角形数量
    3. 模型的有效渲染像素比例尽量大，减少没必要的overdraw（特效），特效模型尽量简单
2. 贴图：
    1. 贴图压缩
    2. 合并贴图通道，尽量不要留空
3. 渲染材质实例的数量：
    1. Skeleton Mesh 减少渲染一个物体的材质实例 MaterialSlot的数量
    2. Static 物体尽量合批渲染 用同变体

### 5. 材质性能层面的优化

1. 总指令数
    1. 降低材质的总指令数，去除无意义的计算或影响非常小的计算
    2. 非常少用到的或者一次性的效果针对美术资源的级别，如果是AS级可以保留，BC级可以考虑去除或者用现有的效果替代
2. 复杂指令数
    1. 移动端用简单计算拟合复杂指令数如三角函数，用Fast版本，减少复杂指令数数量
    2. 尽量用硬件免费的指令如saturate做01截断
3. 控制流
    1. 减少Shader动态分支 If Else的使用，这样可能会导致Shader所有逻辑都会跑。
4. 贴图读取
    1. 贴图通道合并，尽量一次采样提取多个信息
    2. 考虑用计算的方式生成程序化的Noise，而不是采样贴图
    3. 默认贴图用 `1*1` 像素 减少采样消耗
    4. Component Mask Parameter可以为1张贴图提供四种变数，方便合并贴图通道来使得功能效果复用同类型Mask（会产生变体）
5. 有效像素比
    1. 如果渲染效果占屏幕较大的部分，但顶点数很少，可以考虑在顶点着色器部分实现计算，传到片元着色器。如果顶点数很多，屏幕像素占比却很小，就片元着色器去做计算。

### 6. Render Pass部分的优化

1. 减少RT的切换，切换RT会导致带宽的消耗。使用 SubPass
2. 只存储必要的 RT, 例如使用 MSAA 时, 只存储最后需要的 framebuffer, 将用于 MSAA 的 RT 标记为 `VK_ATTACHMENT_STORE_OP_DONT_CARE`
3. 在延迟渲染中, 如果Shading**不需要考虑周围像素的信息**，则同一个RenderPass的**SubPass**可以考虑用Load的方法，直接在TileMemory里读取贴图的像素，可以减少采样，最后Shading完毕再将RT存回SyetemMemory
4. 合批渲染
