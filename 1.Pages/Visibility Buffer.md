---
Type:
  - Page
aliases: 
tags: 
Status: 
modifiedDate: 星期四, 六月 5日 2025, 10:15:24 上午
---

| 特性    | 前向渲染 (Forward) | 延迟着色 (Deferred)   | 可见性缓冲区 (Visibility Buffer)       |
| ----- | -------------- | ----------------- | -------------------------------- |
| 几何体渲染 | 多遍渲染           | 单遍渲染（写 G-Buffer）  | 单遍渲染（写 Visibility Buffer）        |
| 光照计算  | 每顶点/每像素 多次     | 每像素一次（读 G-Buffer） | 每像素一次（读 Visibility Buffer，再查几何体） |
| 内存带宽  | 较低             | 高（G-Buffer 大）     | 极低（Visibility Buffer 小）          |
| 材质灵活性 | 高              | 较低（G-Buffer 有限）   | 高（直接查原始材质）                       |
| 光源数量  | 差（随光源数线性增加）    | 好（与光源数无关）         | 好（与光源数无关）                        |
| 半透明处理 | 好              | 差（需混合渲染）          | 差（需混合渲染）                         |
| 复杂性   | 低              | 中等                | 高                                |

## 定义

- 认为是[延迟渲染](延迟渲染.md)的一种改进或变体, 主要目标减少内存带宽消耗, Overshading 以及 重复纹理采样

### 核心思想

- 只存储 ID: 在 Buffer 中存储
    - 物体 ID
    - 三角形 ID
    - 重心坐标
    - 等
- 着色时根据 Buffer 中的 ID 倒查顶点数据, 和材质信息, 插值出 uv, 再进行采样等

## 原因

- 传统渲染管线的问题
    - [[前向渲染]]
        - 优点, 简单直接, 支持透明物体
        - 缺点: 当场景中有大量光源时, **每个几何体**的**每个片元**都要对**每个光**计算一次, 而被挡住的片元就是无效计算
        - 通常通过 Early-Z, Z-Prepass, Hi-Z 等技术缓解 
    - [延迟渲染](延迟渲染.md)
        - 优点: 分离几何体处理和光照计算 (最昂贵的)
        - 缺点
            - 占用大量内存带宽, 无法适应移动端
                - G-Buffer的绘制产生的读写带宽往往会成为性能瓶颈
            - 难以处理半透明物体
            - 传统延迟渲染由于不确定的绘制顺序, 导致过多的 overdraw,
                - 由于**物体绘制顺序不是从严格前往后的, 而是不确定的**, 在后面的物体即使暂时通过了深度测试, 写入了 Gbuffer, 仍有可能被之后的物体遮挡, 需要重新写入 Gbuffer 
                - 也就是**重复的读取纹理, 对 Gbuffer 重复的写入**

## 细节

### 实现

Visibility Buffer通常需要这些信息：
- **InstanceID**，表示当前像素属于哪个Instance（16~24 bits）；
- **PrimitiveID**，表示当前像素属于Instance的哪个三角形（8~16 bits）；
- **Barycentric Coord**，代表当前像素位于三角形内的位置，用重心坐标表示（16 bits）；
- **Depth Buffer**，代表当前像素的深度（16~24 bits）；
- **MaterialID**，表示当前像素属于哪个材质（8~16 bits）；
只需要存储大约**8~12 Bytes/Pixel**即可表示场景中所有几何体的材质信息，同时，我们需要维护一个**全局的顶点数据和材质贴图表**,存储了当前帧所有几何体的顶点数据，以及材质参数和贴图。

着色阶段
只需要根据InstanceID和PrimitiveID从全局的Vertex Buffer中索引到相关三角形的信息；进一步地，根据像该素的重心坐标，对Vertex Buffer内的顶点信息（UV，Tangent Space等）进行插值得到逐像素信息；再进一步地，根据MaterialID去索引相关的材质信息，执行贴图采样等操作，并输入到光照计算环节最终完成着色，有时这类方法也被称为**Deferred Texturing**。

### 优势

- 显著减少带宽开销
    - 通常只需要 4 字节每像素
    - 将光照计算相关的几何信息和贴图信息读取延迟到了着色阶段，于是那些屏幕不可见的片元不再读取这些数据. 
        - pixel shader 根据屏幕 uv, 采样位置, 获取纹理 uv 等. 
    - 避免 OverShading, 因为只着色了可见像素
    - 灵活的材质系统
        - 不是打包到 G-Buffer 中的, 比如 Metallic 和 Roughness

> **可与延迟渲染结合, 再加一个 pass, 把材质信息等输出到 Gbuffer 中**  

## 实践

- [Nanite](Nanite.md) 中的 VB
