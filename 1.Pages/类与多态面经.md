---
Type:
aliases: 
tags: 
modifiedDate: 2025/06/18, 18:36:50
---

# 类与多态面经

## 类与多态

- 介绍一下c++中的多态，它的如何实现的？
    - [[C++多态]]
- [[C 和 C++]] 的联系与区别
- 类中的静态变量会在什么时候进行初始化？
    - 全局变量、文件域中的静态变量、类中的成员静态变量[^1]，会在main函数执行前进行初始化
    - 局部静态变量(函数内)在第一次调用时初始化
- 拷贝构造函数和operator=的区别与联系？[拷贝构造函数和拷贝赋值运算符](拷贝构造函数和拷贝赋值运算符.md)
- 拷贝构造函数的参数应该是什么？[拷贝构造函数的参数应该是什么](拷贝构造函数的参数应该是什么.md)
- 构造函数中是否可以调用this指针？[构造函数中是否可以调用 this 指针](构造函数中是否可以调用%20this%20指针.md)
- 拷贝构造函数和拷贝赋值运算符的区别是什么？
    - 拷贝构造函数：以函数类型左值引用为参数的函数，本身是一个**构造函数**，会在**类对象初始化的过程中**进行调用。
    - 拷贝赋值运算符：=**运算符**，它不是构造函数，不会在类对象初始化的过程中进行调用。**=左右两边的对象必须已经完成了初始化**。
- 拷贝构造函数和移动构造函数的区别？
    - 参数不同
        - 拷贝构造参数为左值引用（&）,**一般为const引用**
        - 右值引用（&&）
    - 目的不同
        - 拷贝构造: 拷贝一个已有对象, 对于在堆上的资源, 会申请一片新内存,深拷贝
        - 移动构造: 接管一个已有对象, "窃取"其资源, 会将已有对象的内部资源转移到新对象中。浅拷贝
    - 原对象状态不同
        - 拷贝构造: 原对象可以正常使用
        - 移动构造: 原对象处于无效状态, 通常需要用户保证不被再次使用, 指针处于未定义状态
    - 编译器合成不同
        - 如果我们没有定义拷贝构造函数，编译器会为我们自动合成一个拷贝构造函数。**一定的**
        - 移动构造,见 [[C++构造函数#什么时候编译器会合成移动构造?]]
- 为什么拷贝构造函数的参数必须是引用类型？
    - 目的是为了**防止递归调用**。
    - 如果采取了值传递而不是引用传递，那么为了调用拷贝构造函数，我们就必须拷贝它的实参；但是为了拷贝它的实参，我们就又需要调用拷贝构造函数，如此递归循环，调用永远不会成功。
- 浅拷贝和深拷贝是指什么？区别是什么？怎么实现？
    - [[深拷⻉和浅拷贝]]
- 什么是多继承？多继承可能会出现什么问题？如何解决？
    - [[C++多继承]]
- 类实例在内存中存储形式是什么样子的？
    1. 普通类实例：
        1. 类的成员变量，按照声明的顺序依次存储在内存中。
        2. 成员变量的存储顺序可能会受到内存对齐和内存填充的影响，以保证访问成员变量的效率和内存对齐的要求。一般来说，会填充为类内最宽成员长度的整数倍。
        3. 类实例的大小等于所有成员变量的大小之和，再加上可能的填充字节。[[C++内存对齐]]
    2. 继承关系：
        1. 单继承：派生类的实例包含了基类的成员变量，基类的成员变量按照声明的顺序存储在派生类实例的靠前部分。
        2. 多继承：派生类的实例包含多个基类的成员变量，基类的成员变量按照继承声明的顺序依次存储在派生类实例中。
        3. 虚继承：虚继承用于解决多继承中的菱形继承问题。虚继承会引入虚基类指针和虚基类表，用于管理对于虚基类的访问。
    3. 内存对齐和内存填充：[[C++内存对齐]]
        1. 内存对齐：为了提高访问成员变量的效率，编译器会对成员变量进行内存对齐，使其按照特定的字节边界进行存储。一般来说，会填充为**类内最宽成员长度的整数倍**。
        2. 内存填充：为了满足内存对齐的要求，编译器可能会在成员变量之间插入额外的填充字节。填充字节的数量取决于对齐要求和成员变量的大小。
    4. 其他：
        1. 类的静态成员不占据对象实例的内存空间，成员函数也不占据实例的空间大小。
        2. 如果类内存在虚函数的话，会在类对象实例中生成虚函数表指针
- 如果不使用虚函数，如何实现多态？
    - [[C++多态]]
    - C++的多态分为编译时多态和运行时多态，其中虚函数属于运行时多态。编译时多态可以通过重载,重定义和模板进行实现。
    - 重载是指：在同⼀可访问区内，具有不同参数列表的同名函数。
    - C++中的模板有三种类型：函数模板和类模板,以及 C++14 引入的变量模板
        - 函数模板：函数模板允许定义通用的函数，可以在不同的数据类型上进行操作。函数模板使用 `<typename>` 或 `<class>` 关键字来定义通用的类型参数，然后在函数定义中使用这些类型参数。
        - 类模板：类模板允许定义通用的类，可以在不同的数据类型上实例化。类模板使用 `<typename>` 或 `<class>`关键字来定义通用的类型参数，然后在类定义中使用这些类型参数。
        - 变量模板: 可为常量定义模板形式,例如: `template<typename T> constexpr T pi = T(3.1415);`
- 函数返回值可以参与重载吗？
    - 不可以。即**编译器不根据返回值类型判断重载或重定义**
    - 可以参与函数重载的内容：函数名称，函数形参列表（类型+数量）
    - 形参的名字不参与重载
    - 顶层const不参与重载，底层const可以参与重载[^2] [[C++顶层Const和底层Const]]
- 一个类在各种情况下取sizeof()的结果？ ^2f972a
    - [[C++内存对齐]]
    - 一些规则:
        - 大于等于类的非static成员数据之和
        - 编译器可能会额外添加一些数据，例如虚函数表指针和虚基类指针
        - 为了优化访问效率，编译器会进行内存对齐和内存填充。（一般为最宽成员大小的整数倍）
        - 类对象的大小与成员函数无关。
    - 例子
        - 空类:1 字节. 
            - 空类也可以被实例化，每个实例在内存中具有唯一的地址，为了实现这个目的，编译器会给空类填充一个字节。
        - 派生类虚继承基类：如果派生类使用**虚继承**来继承基类，派生类的大小需要额外添加**一个指向虚基类的指针**[^3]大小。
        - 多重虚继承:
            - C 虚继承了 A, B,则 sizeof(C) = sizeof(A) + sizeof(B)+ 一个虚基类指针+内存对齐
            - B 虚继承 A, C 虚继承 A, D 继承 B,C. 
                - D 继承了 B,C 所以有两个虚基类指针 
                - 再加上共享的 A 的数据成员和对齐
- public，private，protected各自的权限范围？有没有例外？
    - [[CPP继承与派生]]
    1. public：
        1. 可以从类的内部访问。
        2. 可以被其他类和函数访问。
        3. 可以通过类的对象使用直接成员访问运算符（.）来访问。
    2. private：
        1. 只能通过**类的成员函数或友元函数**间接访问[^4]
        2. 不能被其他类和函数访问。
        3. 私有成员对于类的外部是不可见的。即无法使用类的对象进行访问。
    3. protected：
        1. 只能从**类的内部和派生类的内部**进行访问。
        2. 不能被其他类和函数访问。
        3. 受保护的成员可以在派生类中**直接访问**，但在类的外部是不可见的。
    - **例外**:友元函数和友元类,拥有 private 访问权
- struct 和 class的区别？
    - 在c++中，struct默认情况下成员为public的，class则为priavate的，除此之外没有任何区别。
- 创建对象时，基类和派生类的构造顺序是什么样的？
    - 基类的构造函数,多基类取决于继承列表中的顺序
    - 执行类内成员对象的构造函数. 按声明的顺序,而不是它们出现在成员初始化列表中的顺序。
    - 函数体
    - 即
        - 从左到右完成虚基类的构造
        - 从左到右完成普通基类的构造
        - **按照类内成员的声明顺序，完成类内成员的构造**
        - **执行自定义构造函数的函数体。**
    - 析构顺序反着来
- 为什么基类要在派生类之前构造？
    - 每个类只控制自身成员的初始化过程。
    - 派生类的构造函数可能会使用基类中的成员，如果派生类的构造函数先进行调用，此时基类成员还没有进行初始化，会发生未定义的行为。
- 为什么派生类要在基类之前析构？
    - 每个类只负责销毁自身分配的资源。
    - 补充：派生类可能会依赖基类的资源，先析构基类可能导致内存泄漏
    - 基类的析构函数不需要显式调用。
-  手写拷贝构造函数，类中包含两个成员变量：int，char*
    - `strlen` 不统计尾的 `\0`,

    ```cpp
     MyClass(const MyClass &obj):m_int{obj.m_int}
     {
        m_str = new char(strlen(obj.m_str)+1);
        strcpy(m_str, obj.m_str);
     }
    ```

- 什么时候会调用拷贝构造函数？
    1. 拷贝初始化
        1. 注意隐式初始化 `std::string s4 = "111";` 和 `std::string s5 = std::string("111");` 等价.
        2. 由于类型不匹配，编译器会寻找一个能从 `const char*` 创建 `std::string` 的方式。`std::string` 类恰好有一个接受 `const char*` 的构造函数 `std::string(const char*)`。编译器会使用这个构造函数，从 `"111"` 创建一个临时的 `std::string` 对象。
    2. 将一个对象作为实参，传递给一个非引用类型的形参
    3. 从一个返回类型为非引用类型的函数，返回一个对象.
        - 这里有**例外**,编译器可能会使用 [[RVO|NRVO]] 优化, 亦或者是直接使**用移动构造**
    4. 使用{}列表初始化一个数组中的元素或者聚合类中的成员
    5. 对标准库容器进行初始化(`vector<int>{10}`)，或者调用insert或者push的时候
- 介绍一下面向对象的三大核心思想？[[面向对象]]
    - 封装
    - 多态
    - 继承
- 类之间的关系有哪些？
    - has-a 包含关系。即类中的一个成员属性，是另一个已经定义好了的类
    - use-a 一个类使用另一个类，通过类之间的成员函数、友元函数或者传递参数的方式实现。
    - is-a 继承
- 构造函数析构函数可否抛出异常？
    - 构造函数
        - 构造函数可以抛出异常，但是**必须保证在抛出异常之前，将资源释放掉**，防止内存泄漏
        - c++只会对已经完整构造的对象进行析构。如果构造函数抛出异常，该对象视为没有被成功构造，因此当前对象的析构函数不会被执行。可能会造成内存泄漏。
    - 析构函数
        - 可以,但不应该
        - 合理的方法是将异常完全封装在析构函数内部，绝不能将其抛出函数之外。
        - 如果析构函数内发生异常, 异常点之后的程序不会执行，可能会造成某些资源没有释放，内存泄漏
        - 函数中某段代码在异常发生的时候，c++会调用构造对象的析构函数来释放栈资源，如果此时析构函数也抛出异常，则前一个异常尚未处理，又抛出了新的异常。双重异常会导致程序调用std::terminate()函数，直接退出。
- 介绍一下创建类对象的两种方式？[[C++内存区域]]
    - 栈上构造: `A a` 在栈空间内分配内存, 离开栈时自动析构
    - 堆上构造: `A*p = new A()` 使用new运算符为对象在堆空间中分配内存，调用构造函数，并返回void\*指针。
- 在什么情况下必须使用成员初始化列表？初始化列表的初始化过程是什么？
    - 初始化一个引用变量, (引用必须在声明时就绑定到一个对象,之后不能再改变其引用的对象)
    - 初始化 const 成员, 在构造函数体中是对 const 对象赋值
    - 调用基类（父类）的带参构造函数 (基类**没有默认构造函数**的情况)
    - 初始化没有默认构造函数的类成员
    - 初始化列表中的初始化顺序，是**按照类中成员的声明顺序**决定的。
    - 性能敏感的情况
- 介绍一下构造函数的执行顺序？
    - 虚基类
    - 基类(继承列表中顺序)
    - vptr
    - 成员对象(按声明顺序), 初始化列表不影响顺序,只改变初始化方式
    - 构造函数体
- 介绍一下析构函数的执行顺序？反过来即可
    - 析构函数体
    - 以相反的声明顺序，调用类成员对象的析构函数
    - 重写定义对象的vptr
    - 上层非虚基类的析构函数
    - 虚基类析构函数
- 介绍一下this指针？
    1. this指针本身并不是类对象的一部分，一般会存储在调用栈上，指向对象的首地址
    2. 标准情况下，this指针是一个右值
    3. this指针只能在成员函数中使用，在全局函数、静态函数中都无法使用
    4. 在调用成员函数的时候，this指针是一个隐含的参数。const 修饰的是 this 指针
- 在成员函数delete this会发生什么？
    1. 如果对象是静态分配：
        1. 会直接报错（在析构函数后崩溃的 ）
        2. 静态分配的对象，内存由c++运行时管理，delete this会破坏栈的内存布局，导致崩溃
    2. 如果对象是动态分配的：
        1. 会调用对象的析构函数
        2. 在delete this之后，访问对象的成员会引发未定义行为
- 在析构函数delete this会发生什么？
    - delete this会调用对象的析构函数，析构函数又会调用delete this。
    - 这样会导致递归调用，最终导致栈溢出
- 特殊成员函数之间的依赖关系
    - 共六个特殊成员函数
    1. 默认构造函数
    2. 拷贝构造函数
    3. 拷贝赋值运算符
    4. 移动构造函数
    5. 移动赋值运算符
    6. 析构函数
    - 规则： [[C++三法则]] [[C++五法则]]
        1. 只要定义了任意的构造函数，就不会生成默认构造函数
        2. 当定义了析构函数、拷贝构造函数、拷贝赋值运算符，那么就不会生成默认的移动构造函数和移动赋值运算符[^5]
        3. 只要定义了移动构造函数、移动赋值运算符，那么就不会生成默认的拷贝构造函数、拷贝赋值运算符。
            1. 因此，只要Base(Base&&) = delete;就可以删除移动控制和拷贝控制。

^f7f7b5

[^1]: 注意 [[C++17新特性#^597e40|c++17引入的inline static]]

[^2]: ```cpp
    template<typename T>
    typename std::remove_reference<T>::type&& move (T&& t) {
        return static_cast<typename std::remove_reference<T>::type&&>(t);
    }
    ```

[^3]: 指向一个**虚基类表**,
    - 这是一张静态的、属于类的数据表，在编译时生成。
    - 它不存储虚函数指针，只存储**内存偏移量（offsets）**。
    - 表中的每个条目都记录了“从当前子对象的 `vb-ptr` 位置，需要移动多少字节才能找到对应的虚基类”的信息。
[^4]: 派生类可以通过可访问的父类的函数间接访问
[^5]: 此时默认有编译器不好处理的资源
