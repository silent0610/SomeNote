---
Type:
  - Page
aliases: 
tags: 
modifiedDate: 星期二, 六月 3日 2025, 10:25:29 晚上
---
[[拷贝构造函数]]

**拷贝构造函数的参数必须是引用**，并且通常是 `const` **引用**。

## 为什么必须?

>  如果不是, MSVC 编译器会报错

**如果参数是值传递 (`MyClass(MyClass other)`)**：
- 发生无限递归, 栈溢出. 
- 当你尝试调用这个拷贝构造函数时，例如 `MyClass obj2 = obj1;`
- 为了将 `obj1` 作为参数 `other` 传递给构造函数，C++ 编译器首先需要**创建一个 `other` 的副本**。
- 而要创建 `other` 的副本，就**需要调用拷贝构造函数本身**！
- 这会形成一个无限递归的循环：调用拷贝构造函数 -> 需要拷贝参数 -> 再次调用拷贝构造函数 -> ... 最终导致栈溢出和程序崩溃。
**如果参数是引用 (`MyClass(MyClass& other)`)**：
- 当参数通过引用传递时，`other` 仅仅是 `obj1` 的一个**别名**，**没有发生拷贝**。
- 编译器直接将 `obj1` 的地址传递给构造函数，从而避免了递归，并使得构造函数能够访问 `obj1` 的原始数据以进行拷贝操作。

## Const 作用

- **允许从 `const` 对象拷贝**：
    - 通过使用 `const` 引用，你可以从 `const` 对象、非 `const` 对象以及临时对象（临时对象是右值，可以绑定到 `const` 左值引用）进行拷贝构造
- **保证源对象不被修改**：
