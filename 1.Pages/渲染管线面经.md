---
Type:
aliases: 
tags: 
modifiedDate: 2025/07/09, 10:43:06
---

# 渲染管线面经

- GPU 渲染管线有哪些流程？详细讲讲GPU渲染管线？详细说一下渲染管线？什么是渲染管线？图形渲染流水线的各个步骤？渲染流水线组成？介绍一下渲染管线越详细越好？详细讲讲GPU渲染管线？介绍一下渲染管线？
    - [[光栅化渲染管线|Render Pipeline]]
- 什么是模板测试？有哪些作用？除了用模板测试做阴影，还有什么应用？
    - [[模板测试]]
- 模板测试的前一个和后一个都是什么？模板测试发生在哪个阶段？
    - 传统的模板测试位于像素处理阶段的合并阶段, 片元经过像素着色器处理之后, 会经历各种测试和, 最终写入帧缓冲. 一般来说, 顺序为裁剪测试,alpha 测试,模板测试, 深度测试. 值得注意的是, 现代硬件对模板测试有类似 Early-Z 的优化. 
    - 广义上, 前一个为像素处理器, 后一个为写入帧缓冲. 
    - 狭义上, 上一个为 alpha 测试, 下一个为深度测试
- alpha混合了解吗？alpha测试是处于什么阶段？和深度测试哪个先？alpha测试和深度测试的前后顺序？
    - alpha 混合指把透明物体的颜色和其之后的物体的颜色根据 alpha 值混合在一起.
    - [[alpha 测试]]是指将alpha值低于给定阈值值的片元直接抛弃. alpha 测试先于深度测试
        - 一般顺序为 裁剪测试,alpha 测试,模板测试, 深度测试
- 各种alpha的解释？
    - [[alpha 测试]]
    - alpha 混合, 根据 alpha 值混合透明物体颜色和其背后物体颜色
    - [[A2C]]（alpha to coverage) 将片元的透明度值，转换为像素内覆盖的样本数量；即根据透明度值，丢弃其中的若干个样本。与MSAA一起工作。[^1]
- 如何渲染半透明的物体？需要注意什么？描述透明物体与不透明物体的渲染方式？如何画一个透明物体？
    - [[OIT]] 算法是指顺序无关的透明度算法, 无需对透明度排序
    - 传统管线, 由于 z-buffer 只能记录一个深度值, 因此需要先绘制不透明物体, 再按照深度, 严格的从后往前渲染半透明物体. 
    - OIT 算法有
- 深度测试过程、透明非透明物体渲染顺序？ 如何确定这些物体渲染顺序？
    - 每个片元都有深度值,将其与记录在 zbuffer 中的值进行比较, 只有在它前面的, 才能被绘制到颜色缓冲中,并更新 zbuffer. 
    - 一般来说，由于z-buffer只能记录一个深度值，因此需要先渲染不透明物体，然后再渲染透明物体。
    - 对于透明物体来说, 通常需要按照每个片元的深度进行严格的从前往后绘制
        - 在任意给定像素上叠加透明表面时，通常需要严格按照从后往前的顺序进行渲染，如果不这样进行处理的话，会导致错误的感知暗示。
        - 一种实现这种排序的方法是，将透明物体沿着观察方向，按照各自质心到相机的距离大小进行排序。
            - 这种粗略的排序可以很好地运行，但是在各种情况下都存在一些问题。
            - 仅仅是一个近似，位于远处的物体也可能会错误地出现在较近物体的前面；
            - 并且相互贯通重叠的物体，无法针对所有视角都进行正确显示，除非将每个网格都划分成单独的块
- 像素处理后面还有什么？深度测试在哪个阶段？三角形交叉怎么办？
    - 如果这里的像素处理是指像素着色阶段，那么之后还会有合并阶段，深度测试就发生在这个合并阶段。如果指的完整的像素处理阶段（即完成合并操作），那么会将最终形成的帧缓冲输出到屏幕上。
    - 当三角形发生交叉重叠时，如果是不透明物体的，使用画家算法无法正确处理，需要使用z-buffer；如果是透明物体，为了正确结果, 则需要使用一种顺序无关的透明度算法来进行渲染。
- Early-Z发生在什么阶段？
    - [[Early-Z]]
    - 深度测试发生在像素着色阶段后的合并阶段，Early z的字面意思就是早期深度测试，它发生在光栅化阶段之后，像素着色阶段之前，使用已经生成的深度缓冲或者其他缓冲区，来对当前片元进行深度测试。
- Early-Z好处？什么情况下会被禁用？Early-Z以及它失效的情况？
    - [[Early-Z#得失]]
- z值的作用？z-buffer的作用？
    - z-buffer 存储了每个像素的最近片元深度值, 用于判读哪些片元是真正可见的
    - 可以作为各种阴影技术的低层
- 光栅化阶段可以配置的部分有哪些
    - 渲染管线中的阶段分为两部分, 可编程阶段和可配置阶段
    - 可编程阶段可以编写代码完全控制
    - 可配置阶段:这些阶段的功能是固定的，由硬件实现，但开发者可以通过 API 调用来配置它们的参数和状态。
    - 光栅化阶段有两个阶段, 分别是三角形设置和三角形遍历
    - vulkan 中可配置包括
        - 剔除模式, 正面背面不剔除, 正面
        - 填充模式 实体, 线框, 顶点, 
            - `lineWidth`
        - 保守光栅化[^2]
        - viewport 和 scissor
        - 抗锯齿 MSAA
        - depthBias
        - depthClampEnable
- vulkan 中深度测试、模板测试能配置的有哪些？
    - 是否开启深度测试
    - 控制通过测试的条件，例如Greater，GEqual，Less等。
    - 通过测试和未通过测试可以执行的操作
    - 是否可以写入
- 像素着色器之后可以操作的有哪些？
    - 像素着色器后是合并阶段, 其任务是将上一阶段输出的片元颜色和并起来, 其中包含一系列可见性(裁剪测试, alpha 测试,模板测试, 深度测试)
    - 深度测试
        - 比较方式
        - 是否开启
        - 能否写入
    - 模板测试
        - 启用?
        - front 和 back, 正面和背面的图元设置不同的规则
        - 比较函数
        - `failOp`, `passOp`, `depthFailOp`：分别定义当“模板测试失败”、“模板测试通过但深度测试失败”、“模板测试和深度测试都通过”时，对模板缓冲执行什么操作
    - 裁剪测试
        - scissor
    - Alpha 测试 (Alpha Test)
        - **在 Vulkan 中**：**不作为独立的固定功能阶段存在**。在 pixel shader 中手动实现
- 渲染时需要什么数据？对于顶点缓冲区有什么数据是必须的
    - 渲染需要图元信息，例如点、线、三角形等。
    - 顶点缓冲区至少也应当包含顶点的坐标，还可以选择包含法线，顶点颜色，纹理坐标等信息。
- 透明物体、Alpha-Test树叶渲染顺序
    - 这里的树叶渲染，应当指的是使用镂空纹理（使用alpha测试）来进行广告牌渲染，从而模拟远处的树木。这种使用镂空纹理来进行广告牌渲染的方法，可以使用两个三角形来模拟具有复杂轮廓的物体。
        - 镂空纹理: 一种特殊的纹理图片（例如 `.png` 或 `.tga` 格式），它利用了**Alpha 通道**来存储透明度信息
        - 广告牌 (Billboard): 是一个始终朝向摄像机或观察者的简单二维平面（通常是一个由两个三角形拼接成的矩形，即“四边形” Quad）
        - 通过 alpha 测试 将 alpha 值低于阈值的生成片元 discard,将纹理中透明的部分“抠掉”，只留下树木本身。
    - 需要在渲染不透明三角形之后，再去渲染透明的三角形，并且要严格按照从后向前的渲染顺序。
- Z-Fighting产生原因与解决方法
    - [[Z-Fighting]]
- Early-Z，Pre-Z，Hi-Z
    - [[Early-Z]]
    - [[Z-Prepass]]
    - [[Hi-Z]]
- 片元着色之前使用的是什么插值方式
    - 任何顶点属性都可以使用重心坐标来进行插值，但是需要使用透视正确的重心坐标。可以在三角形上对a/w和1/w进行线性插值，其中w是顶点在经过所有变换后的第四个分量，a是我们想要插值出的属性值。
    - [[透视矫正插值]]
- 三角形光栅化方法？
    - 早期光栅化过程使用扫描线方法来确定某个像素是否位于三角形内部，现在已经很少使用了。
    - 现代GPU的光栅化期间，在会使用逐tile的三角形遍历，其主要优势在于，它可以使得像素处理更加连贯，访问纹素的方式也更加连贯。在访问颜色缓冲和深度缓冲时，它还可以更好地利用这种局部性，可以大大增加缓冲命中率。
    - [[NaniteGames104学习#Rendering|nanite]] 使用了软件(comupte shader)光栅化, 逐像素进行
- 裁剪空间做了什么？
    - 我们使用投影矩阵将可视空间（正交投影是一个AABB，透视投影是一个视锥体）变换为一个单位立方体[^3]，这个单位立方体叫做裁剪空间。
    - 我们首先会对单位立方体外的图元进行剔除：完全位于单位立方体外[^4]的图元直接丢弃；完全位于单位立方体内的图元保留；
    - 与单位立方体相交的图元需要进行裁剪，生成一些新的顶点。这里使用四维齐次坐标来完成剪切操作，这是由于齐次坐标在透视空间中的三角形上进行的插值通常并不是线性的，我们需要使用w分量来执行正确的裁剪。
    - 然后执行透视除法（perspective division），将得到的三角形位置转换到三维标准化设备坐标系（normalized device coordinates，NDC）。
- 视锥体一般是针对透视投影而言的，视锥体由6个平面组成，分别是2个远近裁剪平面和4个侧平面。其中近裁剪平面与远裁剪平面平行，一般由用户使用两个代表距离的浮点值进行定义。4个侧平面取决于视场角（FOV）和屏幕长宽比例。
    - 在 GLM 这个库中, 通过提供 fovy,aspect 宽高比,near 和 far 来得到透视投影矩阵
    - GLM 是列主序,hlsl 也是
- 像素点中心在三角形边界时的处理？
    - 当像素中心恰好位于两个三角形边缘或者顶点上时，如何决定这个像素的归属。
    - 例如：假设现在两个三角形共享一条边，并且这条边会经过一个像素中心。那么这个像素应当属于第一个三角形，还是第二个三角形，还是两者都属于呢？这些答案都是错误的。
    - 我们通常会使用决胜局规则（tie-breaker rule），在DirectX中为**左上规则**（top-left rule）。当边缘方程 $e_i(x, y) >0$ 时，该像素位于三角形内部；当边缘方程 $e_i(x, y) =0$ 时，左上规则开始发挥作用：如果这个像素中心位于一个上边缘或者左边缘，那么则认为该像素位于这个三角形内部。
    - 如何判断三角形的一条边缘是否是上边缘或者是左边缘呢？如果一条边是水平的，而其他边都在这条边的下方，那么这条边就是上边缘。如果一条边不是水平的，并且位于三角形的左侧，那么它就是左边缘，这意味着三角形最多可以有两条左边缘。检测一条边是左边缘还是上边缘是很简单的。对于上边缘而言，边缘方程中的 a=0（水平方向）且b<0；而对于左边缘而言，a>0。
    - E(x,y)=ax+by+c=0
        - 当点 `(x, y)` **正好在线上**时，`E(x, y) = 0`。
        - 当点 `(x, y)` 在线的**一侧**时，`E(x, y) > 0`。
        - 当点 `(x, y)` 在线的**另一侧**时，`E(x, y) < 0`。
- 边缘方程是怎么计算的
    - 假设一条边由两个顶点 `v0 = (x0, y0)` 和 `v1 = (x1, y1)` 定义。那么这条边的边函数 `E(x, y) = ax + by + c` 的系数可以通过以下方式计算得出：
    - **`a = y0 - y1`**
    - **`b = x1 - x0`**
    - **`c = x0 * y1 - x1 * y0`**

[^1]: alpha 值有两种解释, 一种是像素大小空间内的覆盖程度. 另一种是描述片元的透明程度. 
[^2]: **标准光栅化**只在“像素中心点”被几何图形（如三角形）覆盖时才生成片段, **保守光栅化**指只要三角形和像素有部分,就生成一个片元
[^3]: 在执行透视除法之前, 看起来不是立方体
[^4]: xyz 分量与 w 分量进行比较, 都比 w 大就被丢弃
