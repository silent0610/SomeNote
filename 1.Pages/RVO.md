---
Type:
  - Page
aliases:
  - 返回值优化
  - Return Value Optimization
  - NRVO
  - Named Return Value Optimization
tags: 
modifiedDate: 星期二, 六月 3日 2025, 7:07:53 晚上
---
C++ 编译器通常会执行返回值优化

> 在 C++17 之后，某些情况下的拷贝省略（包括返回匿名临时对象）是**强制**

## 原理

当函数返回一个局部对象时，编译器可以直接在调用者预留的内存空间中构造这个对象，从而**避免了额外的拷贝构造和移动构造**。这使得返回一个大对象的值变得非常高效，因为它实际上并没有发生复制或移动。

## 例子

直接在 result 的位置构造 temp_struct，没有拷贝/移动

```cpp
LargeStruct createLargeStruct () {
    LargeStruct temp_struct; // 局部变量
    // ... 初始化 temp_struct
    return temp_struct; // 这里编译器会执行 RVO
}
// 在 main 函数中
LargeStruct result = createLargeStruct (); // 直接在 result 的位置构造 temp_struct，没有拷贝/移动
```

## 与 return std::move(xxx) 冲突

- **阻止 RVO**：当你在 `return` 语句中显式使用 `std::move()` 时，你实际上是在告诉编译器：“我已经把这个对象标记为右值了，请你严格执行移动语义，不要再尝试 RVO/NRVO 优化了。”这会**阻止**编译器执行 RVO/NRVO，反而强制进行一次**移动构造**（如果定义了移动构造函数）或一次**拷贝构造**（如果没有移动构造函数）。
- **可能更慢**：一次移动构造通常比一次拷贝构造快（因为它只是转移资源的所有权，而不是复制），但它仍然比 RVO/NRVO 提供的**零成本构造**要慢。
- **语义模糊**：不必要的 `std::move` 会使代码阅读者感到困惑，误以为这里有什么特殊的需求。

### 实践

#### 关闭 所有 优化, c++11, Gcc

- 直接 return
    - 一次构造 (函数内局部变量)
    - 一次移动构造 (主程序临时对象)[^1]
    - 一次移动构造 (主程序局部变量) ==临时对象是右值==
- std:: move 
    -  一次构造 (函数内局部变量)
    - 一次移动构造  (主程序临时对象)
    - 一次移动构造 (主程序局部变量) 

#### 不关闭优化

- 直接 return 
    - 一次构造 (主程序局部变量)
- std::move
    - 一次构造 (函数内局部变量)
    - 一次移动构造
    - 这种情况下, **NRVO 还是优化掉了临时对象的移动构造**

[^1]: **将一个具名局部变量（`a`，一个左值）返回时，如果目标是一个右值上下文（即接收函数返回值的临时对象），并且该类型有移动构造函数，C++ 标准允许编译器进行**隐式移动**。**从 C++11 开始，将一个即将销毁的具名局部对象移动到函数返回值位置（或用于初始化一个右值引用）时，编译器会优先选择移动构造函数。**
